;Программа шпион предназначена за контролем обмена между микросхемо FM приемника (Si4730)
;и контроллером радиоприемника SUPRA SFD-85U и передачей всего обмена по RS-232 на компьютер
;будем использовать штатный USART для передачи данных на компьютер 38400

; логика работы:
; поскольку скорость приема высока и в перерывах между транзакциями отправлять на компьютер
; не успеем создаем несколько буферов работающих по кольцу.
; Изначально указатели буферов нулевые. Прием осуществляем по прерываниям по выводам INT0(SCLK) и INT1(SDA)
; INT1 настроен на прерывание по любому изменению лог уровня, INT0 - на прерывание по подъему с низкого на высокий уровень (0->1)
; На INT1 фиксируем (при высоком INT0) начало и конец транзакции и соответствующе обрабатываем.
; На INT0 когда идет транзакция принимаем и фиксируем биты. Каждый байт из 8 битов (старший - первый) + бит ASK/NASK = итого 9 бит
; Для каждого принятого байта в буфере 2 места: сам байт и второй 0 или 1 в зависимости от ASK.
; Опытным путем установлено что транзакции разной длины и не более 8 байт.
; Размер буфера устанавливаем 8*2+1= 17
; По размеру ОЗУ уместилось 7 буферов индексы 0 - 6
; Передачу осуществляем когда закончится транзакция посылая первый байт, потом по прерыванию окончания передачи - остальные 
; до конца буфера.



.include "..\_AVR_ASSEMBLER\DEFs\tn2313def.inc"
.equ 	t1			=$60
.equ 	t2			=$61
.equ 	t3			=$62

; ==============================================
; для F=8МГц (внутренний RC генератор)
; Фьюзы: для USBASP и PonyProg 	1 => установленный бит => галки нет
;								0 => сброшенный бит => отмечено галкой
; все биты LOCK установлены
;---- Fuse High Byte ----
; DVEN - 
; EESAVE -
; SPIEN - V (недоступен)
; WDTON -
; BODLEVEL2 -
; BODLEVEL1 -
; BODLEVEL0 -
; RSTDISBL -   (недоступен)
;---- Fuse Low Byte ----
; CKDIV8 -
; CKOUT -
; SUT1 - 
; SUT0 - V
; CKSEL3 - V
; CKSEL2 -
; CKSEL1 - V
; CKSEL0 - V
; ==============================================

.dseg	;сектор ОЗУ 128 байт, здесь же и стек
.org 0x063
buff0:		.byte 17		;буфер принятых байтов: первый байт - кол-во байтов
buff1:		.byte 17		;буфер принятых байтов: первый байт - кол-во байтов
buff2:		.byte 17		;буфер принятых байтов: первый байт - кол-во байтов
buff3:		.byte 17		;буфер принятых байтов: первый байт - кол-во байтов
buff4:		.byte 17		;буфер принятых байтов: первый байт - кол-во байтов
buff5:		.byte 17		;буфер принятых байтов: первый байт - кол-во байтов
buff6:		.byte 17		;буфер принятых байтов: первый байт - кол-во байтов

.def BUF_AR	= r25		;активный буфер для чтения
.def BUF_PR	= r24		;позиция байта для чтения при следующей передачи в активном буфере
.def BUF_AW	= r23		;активный буфер для записи
.def BUF_PW	= r22		;позиция байта для записи при следующей передачи в активном буфере
	
.def RES_BIT	= r21		;счетчик битов приемного байта
.def STATUS		= r20		;
	;STATUS: 1бит - 0= нет передачи по RS транзакции, 1 - начата передача по RS транзакции
	;STATUS: 0бит - 0= нет приема транзакции, 1 - начат прием транзакции

.cseg
.org 0x000
	rjmp start
.org INT0addr	;0x001
	rjmp ChangeCLK			;при возникновении прерывания INT0
.org INT1addr	;0x002
	rjmp ChangeDAT	     	 ;при возникновении прерывания INT1
; .org OVF2addr	;0x008
	; rjmp over_82			;переполнение 2-го 8-разрядного счетчика (АСУ удерживает линию в низком состоянии очень долго) ~2мс
.org UTXCaddr	; 0x0009	USART, Tx Complete
	rjmp USART_TX_Complete
; .org OVF0addr	;0x012
	; rjmp over_8				;при переполнении счетчика ~2мс от начала первого байта (слово из 8 байт = 1,4мс) анализ принятого
;===============================================
.org 0x030
start:
	ldi r16,low(RAMEND)
	out spl,r16
	clr r10					;R10 - 00000000
	ser r16
	mov r11,r16				;R11 - 11111111
	rcall d_200ms
;===============================================
; Настройка портов => DDRx = 1(out); 0 = (in)   PORTx = 1(подтянут к +); 0(в воздухе - 0)
; Порт A (-,-,-,-,-,2,1,0)
	; ldi r16,0b00000001
	; out DDRA,r16
	; ldi r16,0b00000001
	; out PORTA,r16

; Порт B (7,6,5,4,3,2,1,0)
	; out DDRB,r11			;
	; ldi r16,0b00000111
	; out PORTB,r16

; Порт D (-,6,5,4,3,2,1)
	ldi r16,0b01100000
	out DDRD,r16
	ldi r16,0b00010000
	out PORTD,r16
;===============================================
; Настройка USART
; скорость возьмем 38400
	; установка скорости 
	out UBRRH,r10
	; ldi r16,12
	ldi r16,1		;250000 ст=256000 
	out UBRRL,r16
	; ускоритель скорости на 2 выключим (U2X = 0 - 1 бит UCSRA)
	out UCSRA,r10
	; включим только передатчик (для включения приемника тоже сделать: (1<<RXEN)|(1<<TXEN)
	;TXCIE - разрешить прерывание по окончании передачи байта
	ldi r16,(1<<TXEN)|(1<<TXCIE)
	out UCSRB,r16
	; установка формата кадра (3<<UCSZ0)=011=8бит	(7<<UCSZ0)=111=9бит
	ldi r16,(0<<UMSEL)|(0<<UPM0)|(0<<UPM1)|(0<<USBS)|(3<<UCSZ0)
	out UCSRC,r16
;===============================================
; Настройка прерываний
	ldi r16,(3<<ISC00)|(1<<ISC10)		; установка прерываний по любому изменению уровня INT0 и INT1
	;(3<<ISC00)11 - по переднему фронту,(2<<ISC00)10 - по заднему фронту,(1<<ISC00)01 - по любому изменению
	out MCUCR,r16
	ldi r16,(1<<INT0)|(1<<INT1)		; установка прерываний по INT0 и INT1
	out GIMSK,r16

	clr BUF_AR
	clr BUF_PR
	clr BUF_AW
	clr BUF_PW
	clr RES_BIT
	clr STATUS
	
	ldi zh,high(buff0)
	ldi zl,low(buff0)
	st z,r10		;кол-во байтов
	ldi zh,high(buff1)
	ldi zl,low(buff1)
	st z,r10		;кол-во байтов
	ldi zh,high(buff2)
	ldi zl,low(buff2)
	st z,r10		;кол-во байтов
	ldi zh,high(buff3)
	ldi zl,low(buff3)
	st z,r10		;кол-во байтов
	ldi zh,high(buff4)
	ldi zl,low(buff4)
	st z,r10		;кол-во байтов
	ldi zh,high(buff5)
	ldi zl,low(buff5)
	st z,r10		;кол-во байтов
	ldi zh,high(buff6)
	ldi zl,low(buff6)
	st z,r10		;кол-во байтов

	sei
;===============================================
loop:
; Основной цикл программы.
; Отслеживаем буфера и если буфер не пуст а указатель приемника не на нем - отправляем буфер на компьютер.
; Буфер пуст/не пуст - по первому байту буфера - 0 = пуст, не 0 = кол-во байтов в буфере
			sbis PIND,4
			rcall ButtonDown


			sbrc STATUS,1		;пропустить если нет передачи по RS транзакции
			rjmp loop
			;Последовательно проверяем каждый буфер с 0 по 6
			; если не пуст и указатель приема не на нем(BUF_AW) - передаем на комп
			clr r17				;смещение
			ldi r16,-1			;индекс буфера
	lop1:	inc r16
			cpi r16,7
			brne lop2
			rjmp loop			;прошли все буфера
	lop2:	cp r16,BUF_AW
			breq lop1			;буфер еще на приеме
			rcall GetZBuf		;загрузим в zh,zl адрес буфера
			ld r18,z
			tst r18
			breq lop1
			;нашли не пустой буфер
			mov BUF_AR,r16		;активный буфер для чтения
			clr BUF_PR			;позиция байта для чтения - начнем с 0
			sbr STATUS,0b00000010	;установим процесс передачи по RS транзакции
			rcall OutByteToRS232	;начнем отправку
			
rjmp loop
;===============================================
ButtonDown:
			sbi PORTD,6
			rcall d_200ms
			cbi PORTD,6
	clr BUF_AR
	clr BUF_PR
	clr BUF_AW
	clr BUF_PW
	clr RES_BIT
	clr STATUS
	
	ldi zh,high(buff0)
	ldi zl,low(buff0)
	st z,r10		;кол-во байтов
	ldi zh,high(buff1)
	ldi zl,low(buff1)
	st z,r10		;кол-во байтов
	ldi zh,high(buff2)
	ldi zl,low(buff2)
	st z,r10		;кол-во байтов
	ldi zh,high(buff3)
	ldi zl,low(buff3)
	st z,r10		;кол-во байтов
	ldi zh,high(buff4)
	ldi zl,low(buff4)
	st z,r10		;кол-во байтов
	ldi zh,high(buff5)
	ldi zl,low(buff5)
	st z,r10		;кол-во байтов
	ldi zh,high(buff6)
	ldi zl,low(buff6)
	st z,r10		;кол-во байтов

	ldi zh,high(buff6)
	ldi zl,low(buff6)
	ldi r16,11
	st z+,r16		;кол-во байтов
	ldi r16,'S'
	st z+,r16
	ldi r16,'t'
	st z+,r16
	ldi r16,'a'
	st z+,r16
	ldi r16,'r'
	st z+,r16
	ldi r16,'t'
	st z+,r16
	ldi r16,'R'
	st z+,r16
	ldi r16,'S'
	st z+,r16
	ldi r16,'T'
	st z+,r16
	ldi r16,0x0D
	st z+,r16
	ldi r16,0x0A
	st z+,r16

	ldi zh,high(buff0)
	ldi zl,low(buff0)
	ldi r16,13
	st z+,r16		;кол-во байтов
	ldi r16,'E'
	st z+,r16
	ldi r16,'f'
	st z+,r16
	ldi r16,'a'
	st z+,r16
	ldi r16,'r'
	st z+,r16
	ldi r16,'t'
	st z+,r16
	ldi r16,'R'
	st z+,r16
	ldi r16,'S'
	st z+,r16
	ldi r16,'T'
	st z+,r16
	ldi r16,'T'
	st z+,r16
	ldi r16,'E'
	st z+,r16
	ldi r16,0x0D
	st z+,r16
	ldi r16,0x0A
	st z+,r16

	inc BUF_AW
ret
;===============================================
OutByteToRS232:
			sbrs STATUS,1		;пропустить если передача по RS транзакции
			ret
			
			push zh
			push zl
			push r18
			push r17
			push r16
			
			mov r16,BUF_AR			;индекс буфера
			clr r17				;смещение
			rcall GetZBuf		;загрузим в zh,zl адрес буфера
			ld r18,z
			tst r18
			brne obtr1
			;конец буфера - конец передачи
			cbr STATUS,0b00000010	;сбросим процесс передачи по RS транзакции
			rjmp obtrOut
	obtr1:
			dec r18				;уменьшим размер буфера
			st z,r18			;сохраним
			
			mov r17,BUF_PR		;смещение
			rcall GetZBuf		;загрузим в zh,zl адрес буфера
			ld r16,z			;загрузим передаваемый байт
	obtr2:	sbis UCSRA,UDRE
			rjmp obtr2
			out UDR,r16
			inc BUF_PR			;увеличим смещение
			
obtrOut:	pop r16
			pop r17
			pop r18
			pop zl
			pop zh
ret
;===============================================
USART_TX_Complete:	;очередной байт был передан успешно
	rcall OutByteToRS232	;выводим следующий байт
reti
;===============================================
ChangeCLK:	;PORTD,2
			sbrs STATUS,0		;пропустить если начат прием транзакции
			reti				;если нет транзакции - выходим
			
			push zh
			push zl
			push r16
			push r17
			push r18
			
; .def BUF_AW	= r23		;активный буфер для записи
; .def BUF_PW	= r22		;позиция байта для записи при следующей передачи в активном буфере
; .def RES_BIT	= r20		;счетчик битов приемного байта
	
			; cpi RES_BIT,9
			; brne chc1
			cpi RES_BIT,8
			brne chc1
			;если это 9 бит - ASK
			clr RES_BIT
			inc BUF_PW
			;сохраним ASK как отдельный байт
			inc BUF_PW
			mov r16,BUF_AW
			mov r17,BUF_PW		;смещение
			rcall GetZBuf		;загрузим в zh,zl адрес буфера
			clr r17
			sbic PIND,3		;пропустить если DAT high
			inc r17
			st z,r17
			
			rjmp chcOut
	chc1:	;если это очередной бит  следующего байта
			sbis PIND,3		;пропустить если DAT high
			rjmp chc2
			;запишем 1 в соответствующий бит
			mov r16,BUF_AW
			mov r17,BUF_PW		;смещение
			inc r17
			rcall GetZBuf		;загрузим в zh,zl адрес буфера
			tst RES_BIT			;если это первый бит, очистим байт
			brne chc3
			st z,r10
	chc3:	
			ldi r18,0b10000000
			ld r16,z
			mov r17,RES_BIT
	chc4:	tst r17
			breq chc5
			ror r18
			dec r17
			rjmp chc4
	chc5:	add r16,r18
			st z,r16
	chc2:
			inc RES_BIT
	chcOut:
			pop r18
			pop r17
			pop r16
			pop zl
			pop zh
reti
;===============================================
ChangeDAT:	;PORTD,3
;изменение на этом выводе при CLK high: DAT стал низким - начало транзакции, DAT стал высоким - конец транзакции
			sbis PIND,2		;пропустить если CLK high
			reti				;если CLK low - выходим
			
			sbis PIND,3		;пропустить если DAT high
			rjmp chd1
			;конец транзакции
			cbr STATUS,0b00000001
			cbi PORTD,5
			;сохраним кол-во принятых байтов
			push zh
			push zl
			push r16
			push r17
			mov r16,BUF_AW
			clr r17				;смещение
			rcall GetZBuf		;загрузим в zh,zl адрес буфера
			inc BUF_PW
			st z,BUF_PW
			
			;увеличиваем индекс буфера для приема
			;проверим свободен ли следующий буфер (по кол-ву байтов)
			inc BUF_AW		;активный буфер для записи
			cpi BUF_AW,7
			brne chd3
			clr BUF_AW
	chd3:	
			mov r16,BUF_AW
			clr r17				;смещение
			rcall GetZBuf		;загрузим в zh,zl адрес буфера
			ld r16,z			;увеличим кол-во принятых байтов
			tst r16
			breq chd4
			;буфер не очищен!!!
			sbi PORTD,6
			
	chd4:	
			pop r17
			pop r16
			pop zl
			pop zh
			
			reti
chd1:		;начало транзакции
			sbr STATUS,0b00000001
			sbi PORTD,5
			clr BUF_PW		;позиция байта для записи при следующей передачи в активном буфере
			clr RES_BIT		;счетчик битов приемного байта

reti
;===============================================
GetZBuf:	;r16 - индекс буфера, r17 - смещение
			cpi r16,0
			brne gzb1
			ldi zh,high(buff0)
			ldi zl,low(buff0)
	gzb1:	cpi r16,1
			brne gzb2
			ldi zh,high(buff1)
			ldi zl,low(buff1)
	gzb2:	cpi r16,2
			brne gzb3
			ldi zh,high(buff2)
			ldi zl,low(buff2)
	gzb3:	cpi r16,3
			brne gzb4
			ldi zh,high(buff3)
			ldi zl,low(buff3)
	gzb4:	cpi r16,4
			brne gzb5
			ldi zh,high(buff4)
			ldi zl,low(buff4)
	gzb5:	cpi r16,5
			brne gzb6
			ldi zh,high(buff5)
			ldi zl,low(buff5)
	gzb6:	cpi r16,6
			brne gzb7
			ldi zh,high(buff6)
			ldi zl,low(buff6)
	gzb7:	
			add zl,r17			; прирастим позицию
			brcc gzbOut			;если перенос инкременируем старший разряд
			inc zh
	gzbOut:
ret
;===============================================
; ----------------------------------------------
;БЛОК ЗАДЕРЖЕК		расчет задержек включает вход и выход из подпрограммы задержки
; ----------------------------------------------
; d_1mks:	; 3(rcall)+1+4(ret) = 8*0,125 = 1.0 мкс
		; nop
		; ret
; ----------------------------------------------
; d_500mks:	; 41+{ t1*(5+t2*(5+(t3*3-1))-1)-1 } = 4028*0.125 = 503,5мкс
		; push r16
		; ldi r16,1
		; sts t1,r16
		; ldi r16,6
		; sts t2,r16
		; ldi r16,220
		; sts t3,r16
		; rcall delay
		; pop r16
		; ret
; ----------------------------------------------
; d_1ms:	; 41+{ t1*(5+t2*(5+(t3*3-1))-1)-1 } = 8012*0.125 = 1001,5мкс
		; push r16
		; ldi r16,1
		; sts t1,r16
		; ldi r16,12
		; sts t2,r16
		; ldi r16,220
		; sts t3,r16
		; rcall delay
		; pop r16
		; ret
; ----------------------------------------------
; d_20ms:	; 41+{ t1*(5+t2*(5+(t3*3-1))-1)-1 } = 160765*0.125 = 20095,625мкс = 20,096мс
		; push r16
		; ldi r16,1
		; sts t1,r16
		; ldi r16,21
		; sts t2,r16
		; ldi r16,254
		; sts t3,r16
		; rcall delay
		; pop r16
		; ret
; ----------------------------------------------
d_200ms:
		push r16
		ldi r16,9
		sts t1,r16
		ldi r16,232
		sts t2,r16
		ldi r16,255
		sts t3,r16
		rcall delay
		pop r16
		ret
; ----------------------------------------------
d_800ms:	; 3(rcall)+2+1+2+1+2+1+2+3(rcall)+[2+2+2+2+{ t1*(5+t2*(5+(t3*3-1))-1)-1 }+2+2+2+4(ret)]+2+4(ret) = X*T(0.125) = 
			; 41+{ t1*(5+t2*(5+(t3*3-1))-1)-1 } = 41+ 34*188504-1 = 6409176*0.125 = 801147мкс = 801,147мс
		push r16	;2
		ldi r16,34	;1
		sts t1,r16	;2
		ldi r16,250	;1
		sts t2,r16	;2
		ldi r16,250	;1
		sts t3,r16	;2
		rcall delay	;3
		pop r16		;2
		ret			;4
; ----------------------------------------------
;использование см. выше. минимум(1,1,1)= 41+{1*(5+1*(5+(1*3-1))-1)-1 } = 51*0.125 = 6.375мкс
delay:	
		push r13	;2
		push r14	;2
		push r15	;2
		lds r15,t1	;2
del3:	lds r14,t2	;2
del2:	lds r13,t3	;2
del1:	dec r13		;1
		brne del1	;2/1
		dec r14		;1
		brne del2	;2/1
		dec r15		;1
		brne del3	;2/1
		pop r15		;2
		pop r14		;2
		pop r13		;2
		ret			;4
; ----------------------------------------------
