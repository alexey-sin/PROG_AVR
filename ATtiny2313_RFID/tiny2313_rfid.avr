.include "..\_AVR_ASSEMBLER\DEFs\tn2313def.inc"
.equ 	t1			=$60
.equ 	t2			=$61
.equ 	t3			=$62

; .equ DELAY_OF_SECURITY	= 3		;время в секундах перед постановкой на охрану(не более 255 => 4.25мин)

; .eseg	;EEPROM энергоНЕзависимая память 128 байт
; .org 0x000	;EEPROM прошивать ненадо, эти номера контроллер запишет сам при настройке
; smsc:	.db 7, 9,0,3, 7,0,1, 1,1, 1,1	;телефон SMS сервис центра (1байт- кол-во знаков в номере)79037011111
; .org 0x010
; da:		.db 7, 9,1,5, 9,6,3, 3,6, 8,5	;телефон получателя (1байт- кол-во знаков в номере)

.dseg	;сектор ОЗУ 128 байт, здесь же и стек
.org 0x063
buffer: 		.byte 8	;буфер для приема ответов от RFID

; ==============================================
; ==============================================
; для F = 16МГц (внешний кварц)
; Фьюзы: для USBASP и PonyProg 	1 => установленный бит => галки нет		( )
;								0 => сброшенный бит => отмечено галкой 	(V)
; все биты LOCK установлены
;---- Fuse High Byte ----
; DWEN - 				(если V и LOCK не установлены влючается режим отладки debugWIRE через вывод RESET
; EESAVE -
; SPIEN - V (недоступен)
; WDTON -
; BODLEVEL2 -
; BODLEVEL1 -
; BODLEVEL0 -
; RSTDISBL -   (недоступен)
;---- Fuse Low Byte ----
; CKDIV8 -
; CKOUT -
; SUT1 -
; SUT0 - 
; CKSEL3 - 
; CKSEL2 -
; CKSEL1 - 
; CKSEL0 - 
; ==============================================
; ==============================================

; .def DES_KEY_DAT	= r22		;биты активности датчиков 0-активен, 1-дизактивен
	; ;DES_KEY_DAT: 5бит	датчик 3
	; ;DES_KEY_DAT: 4бит	датчик 2
	; ;DES_KEY_DAT: 3бит	датчик 1
	
	; ;DES_KEY_DAT: 1бит	низкое напряжение батареи

; .def KEY_DAT	= r23		;биты повторители выводов порта PB	
	; ;KEY_DAT: 5бит	датчик 3
	; ;KEY_DAT: 4бит	датчик 2
	; ;KEY_DAT: 3бит	датчик 1
	; ;KEY_DAT: 2бит	кнопка START
	; ;KEY_DAT: 1бит	аналоговый компаратор (питание 1-низкое напряжение) только для режима охраны
	; ;KEY_DAT: 0бит	кнопка SET
	
; .def STATUS		= r25		;статус состояния устройства
	; ;STATUS: 7бит - 1= начальная включение и инициализация SIM900 прошла успешно
	; ;STATUS: 6бит - 1= временный выход из режима охраны (0 - обычное состояние)
	; ;STATUS: 5бит - 1= PDU послано, ожидается ответ
	; ;STATUS: 4бит - 1= антидребезг контактов кнопок и датчиков, запрещена реакция по выводам; 0 - обычный режим
	; ;STATUS: 3бит - 1= режим охрана; 0 - обычный режим
	; ;STATUS: 2бит - 1= блокировка буфера приема (0 - буфер свободен)
	; ;STATUS: 1бит - 1= режим настройки (0 - обычный режим)

; .def IDENT		= r24		;идентификатор полученных ответов от модуля

	; ;IDENT: 5бит - 1= "+CBC:" - ответ на запрос о батарее
	; ;IDENT: 4бит - 1= "+CMGS:" - ответ на отправление смс
	; ;IDENT: 3бит - 1= наличие номера хозяина
	; ;IDENT: 2бит - 1= наличие номера smsc центра
	; ;IDENT: 1бит - 1= готовность устройства "+CPAS:"
	; ;IDENT: 0бит - 1= Получен "ОК"
	
.def COUNTER_TAKT_4mks	= r5		;счетчик тактовых импульсов 125кГц

.def MOD_LOW_SHORT	= r12		;Нижняя граница короткого интервала по счетчику тактовых импульсов 4мкс
.def MOD_HIGH_SHORT	= r13		;Верхняя граница короткого интервала по счетчику тактовых импульсов 4мкс
.def MOD_LOW_LONG	= r14		;Нижняя граница длинного интервала по счетчику тактовых импульсов 4мкс
.def MOD_HIGH_LONG	= r15		;Верхняя граница длинного интервала по счетчику тактовых импульсов 4мкс

.def RESIVER_MOD		= r25		;приемник модулированного сигнала
	;RESIVER_MOD: 7бит - 1 = Общая ошибка приема по интервалам модулированного сигнала - прием по прерываниям запрещен; 0 = Все нормально
	;RESIVER_MOD: 6бит - 1 = Переполнение счетчика COUNTER_TAKT_4mks; 0 = Все нормально
	;RESIVER_MOD: 5бит - 1 = Ошибка приема по интервалам модулированного сигнала - интервал короче короткого; 0 = Все нормально
	;RESIVER_MOD: 4бит - 1 = Ошибка приема по интервалам модулированного сигнала - интервал длинее короткого и короче длинного; 0 = Все нормально
	;RESIVER_MOD: 3бит - 1 = Ошибка приема по интервалам модулированного сигнала - интервал длинее длинного; 0 = Все нормально
	;RESIVER_MOD: 2бит - 1 = Принят short (200-300mks)
	;RESIVER_MOD: 1бит - 1 = Принят long (400-600mks)
	;RESIVER_MOD: 0бит - 1 = Принят новый интервал (в 0 сбрасывается обработчиком)

.def BIT_COUNTER		= r24		;

.def DATA_STATUS		= r23		;
	;DATA_STATUS: 7бит - 1 = Установлена синхронизация по данным; 0 = нет синхронизации
	;DATA_STATUS: 6бит - 1 = Заголовок (9 бит "1") принят; 0 = нет заголовка
	;DATA_STATUS: 5бит - 1 = 
	;DATA_STATUS: 4бит - 1 = 
	;DATA_STATUS: 3бит - 1 = 
	;DATA_STATUS: 2бит - 1 = 
	;DATA_STATUS: 1бит - 1 = 
	;DATA_STATUS: 0бит - 1 = 
;===============================================
; Блок прерываний - каждый адрес/ссылка = 2 байта
.cseg
.org	0x0000			rjmp start	;
.org	INT0addr		rjmp RFID_Int	; External Interrupt Request 0
.org	INT1addr		reti	; External Interrupt Request 1
.org	ICP1addr		reti	; Timer/Counter1 Capture Event
.org	OC1Aaddr		reti	; Timer/Counter1 Compare Match A
.org	OVF1addr		reti	; Timer/Counter1 Overflow (при переполнении счетчика(16бит))
.org	OVF0addr		reti	; Timer/Counter0 Overflow (при переполнении счетчика(8бит))
.org	URXCaddr		rjmp Receive_Int	; USART, Rx Complete (при возникновении прерывания RXC)
.org	UDREaddr		reti	; USART Data Register Empty
.org	UTXCaddr		reti	; USART, Tx Complete
.org	ACIaddr			reti	; Analog Comparator
.org	PCIaddr			reti	; при изменении сигналов на выводах PB0-7
.org	OC1Baddr		reti	; 
.org	OC0Aaddr		rjmp OC0A_OVF	; 
.org	OC0Baddr		reti	; 
.org	USI_STARTaddr	reti	; USI Start Condition
.org	USI_OVFaddr		reti	; USI Overflow
.org	ERDYaddr		reti	; 
.org	WDTaddr			reti	; Watchdog Timer Overflow
;===============================================
.org 0x020
start:

	ldi r16,low(RAMEND)
	out spl,r16
	; ; rcall d_1000ms
	
	clr r10					;R10 - 00000000
	ser r16
	mov r11,r16				;R11 - 11111111

;===============================================
; Настройка портов => DDRx = 1(out); 0 = (in)   PORTx = 1(подтянут к +); 0(в воздухе - 0)
; Порт A (-,-,-,-,-,2,1,0)
	; ldi r16,0b00000011
	; out DDRA,r16
	; ldi r16,0b00000011
	; out PORTA,r16

; Порт B (7,6,5,4,3,2,1,0)	PB2(OC0A) - как выход с подтягивающим резистором для выхода 125кГц
	ldi r16,0b00000100
	out DDRB,r16
	ldi r16,0b00000100
	out PORTB,r16

; ; Порт C
	; ; out DDRC,r11			;все выводы работают как выход
	; ; out PORTC,r10			;без подтягивающих резисторов т.е. 0

; Порт D (-,6,5,4,3,2,1,0)	PD2(INT0) - вход импульсов от ридера RFID - красный светодиод
;							PD4 - зелёный светодиод
	ldi r16,0b00010000
	out DDRD,r16
	ldi r16,0b00010000
	out PORTD,r16
;===============================================
; Настройка 8 разрядного таймера на генерацию 125 кГц
	ldi r16,0b01000010	;режим СТС, генерация
	out TCCR0A,r16
	ldi r16,0b00000001	;без предварительного деления
	out TCCR0B,r16
	ldi r16,0b00111111
	out OCR0A,r16
	; out OCR0B,r16
;===============================================
; Аналоговый компаратор		(Отключение 0b10000000 => ACSR)
	ldi r16,0b01000000
	out ACSR,r16
	ldi r16,0b00000010		; Блокируем цифровой ввод по AIN1
	out DIDR,r16
;===============================================
; Настройка USART
; скорость возьмем 38400
	; установка скорости 
	out UBRRH,r10
	ldi r16,25		;12 для 38400 при 8МГц;  25 для 38400 при 16МГц
	out UBRRL,r16
	; ускоритель скорости на 2 выключим (U2X = 0 - 1 бит UCSRA)
	out UCSRA,r10
	; (для включения приемника тоже сделать: (1<<RXEN)|(1<<TXEN)
	;TXEN - включения передатчика
	;RXEN - включения приемника
	;TXCIE - разрешить прерывание по окончании передачи байта	|(1<<TXCIE)
	;RXCIE - разрешить прерывание по окончании приема байта
	ldi r16,(1<<TXEN)|(1<<RXEN)|(1<<RXCIE)
	out UCSRB,r16
	; установка формата кадра (3<<UCSZ0)=011=8бит	(7<<UCSZ0)=111=9бит
	ldi r16,(0<<UMSEL)|(0<<UPM0)|(0<<UPM1)|(0<<USBS)|(3<<UCSZ0)
	out UCSRC,r16
	out UDR,r10		;очистим буфер приема-передачи
;===============================================
; Настройка прерываний
	ldi r16,(1<<ISC00)		; установка прерываний по любому изменению уровня INT0
	out MCUCR,r16
	ldi r16,(1<<INT0)		; установка прерываний по INT0  (для INT1 |(1<<INT1))
	out GIMSK,r16
	
	ldi r16,0b00000001		;0b00000001 разрешить прерывание по совпадению на канале А 0(8разр) счетчика  ;  0b00000010 разрешить прерывание по переполнению 0(8разр) счетчика
	out TIMSK,r16			;или 0b10000010 разрешить прерывание по переполнению 0(8разр) и 1(16разр) счетчиков
;===============================================
;===============================================
	; ldi zh,high(buffer)
	; ldi zl,low(buffer)
	; st z,r10   			;Установить указатель сообщения в ноль	
	
	; ldi yh,high(buff_sms_ascii)
	; ldi yl,low(buff_sms_ascii)
	; st Y,r10   			;Установить указатель сообщения в ноль	

	; clr IDENT			;обнулим идентификатор полученных ответов от модуля
	; clr STATUS			;обнулим статус состояния устройства
	; clr KEY_DAT			;обнулим состояние выводов PB
	
	cbi PORTD,4		; GREEN
	;обнулим до начального состояния
	clr COUNTER_TAKT_4mks
	clr RESIVER_MOD
	clr BIT_COUNTER
	clr DATA_STATUS
;===============================================
; Установка временных порогов для модулированного сигнала
	ldi r16,50
	mov MOD_LOW_SHORT,r16
	ldi r16,75
	mov MOD_HIGH_SHORT,r16
	ldi r16,100
	mov MOD_LOW_LONG,r16
	ldi r16,150
	mov MOD_HIGH_LONG,r16
; Для стандарта F0/64 короткий промежуток 250мкс а длинный 500мкс	
; Допустим отклонение 20%. COUNTER_TAKT_4mks инкременируется каждые 4мкс
; Тогда короткий промежуток должен быть от 50 до 75 COUNTER_TAKT_4mks (от MOD_LOW_SHORT до MOD_HIGH_SHORT)
; а длинный от 100 до 150 COUNTER_TAKT_4mks (от MOD_LOW_LONG до MOD_HIGH_LONG)
;===============================================
	sei
;##############################################################################################
;##############################################################################################
;##############################################################################################
loop:
			sbrs RESIVER_MOD,7		;пропустить если нет ошибки приема по интервалам модулированного сигнала
			rjmp lp_1
			; Общая ошибка приема по интервалам модулированного сигнала
			; cli
			cbr RESIVER_MOD,0b10000000	;сброс общей ошибки
			sbrs RESIVER_MOD,6		;пропустить если нет Переполнение счетчика COUNTER_TAKT_4mks
			rjmp lp_2
			; Ошибка Переполнение счетчика COUNTER_TAKT_4mks
			cbr RESIVER_MOD,0b01000000	;сброс ошибки Переполнение счетчика COUNTER_TAKT_4mks
			
			rcall RESTART
			cbi PORTD,4		; GREEN
			
			; sei
			rjmp loop
	lp_2:
			; Ошибка Интервалов
			; ldi r17,0xE0			;неизвестная ошибка
			; sbrc RESIVER_MOD,5		;интервал короче короткого
			; ldi r17,0xE1
			; sbrc RESIVER_MOD,4		;интервал длинее короткого и короче длинного
			; ldi r17,0xE1
			; sbrc RESIVER_MOD,3		;интервал длинее длинного
			; ldi r17,0xE1
			; rcall out_byte_RS232
			; sei
			cbr RESIVER_MOD,0b00111000	;сброс ошибок Интервалов
			
			rcall RESTART
			cbi PORTD,4		; GREEN
			
			
			rjmp loop
	lp_1:
			sbrs RESIVER_MOD,0		;пропустить если есть принятый интервал
			rjmp loop
	
	
			sbrs RESIVER_MOD,1		;пропустить если Принят long
			rjmp lp_3
	;====== Принят long
			sbrc DATA_STATUS,7		;пропустить если нет синхронизации
			rjmp lp_6
			clt
			sbic PIND,2
			set
			
			cbr DATA_STATUS,0b10000000	;Есть синхронизация
	lp_6:	
			sbrs DATA_STATUS,6		;пропустить если есть заголовок (9 бит "1")
			rjmp lp_4
			
			; inc BIT_COUNTER
			; inc BIT_COUNTER
			; cpi BIT_COUNTER,20
			; brpl lp_6		;перейти если нет минуса значит не стартовые "1"
			; rcall RESTART
			
			rjmp lp_4
	;====== Принят short
	lp_3:	
			sbrs DATA_STATUS,7		;пропустить если есть синхронизация
			rjmp lp_6
			sbrc DATA_STATUS,6		;пропустить если нет заголовка (9 бит "1")
			rjmp lp_5
			
			
			; inc BIT_COUNTER
			; cpi BIT_COUNTER,18
			; brne lp_5
			
			; sbis PIND,4
			; sbi PORTD,4		; GREEN
			; sbic PIND,4
			; cbi PORTD,4		; GREEN
			; rcall RESTART
			
	lp_5:	
	
	lp_4:	
			cbr RESIVER_MOD,0b00000111	;Принятый интервал обработан
			; cpi r24,255
			; brne tm0_1
			; cpi r25,255
			; breq tm0_2
	; tm0_1:		
			; adiw r24,1
			; ; brcc tm0_3
			; ; subi COUNTER_H,-1
			; ; inc 
			; ; rjmp tm0_4
			
			; ; inc COUNTER_L
	; ; tm0_4:		; inc COUNTER_M
			; ; brne tm0_3
			
			
	; ; tm0_3:	cbi PORTD,4		; GREEN
			; ; sei
			; ; reti
; rjmp loop

	; tm0_2:	;если счетчик уже переполнен
			; sbis PIND,4
			; sbi PORTD,4		; GREEN
			; sbic PIND,4
			; cbi PORTD,4		; GREEN
	; clr r24 	;обнулим счетчик тактовых импульсов 125кГц младший регистр
	; clr r25 	;обнулим счетчик тактовых импульсов 125кГц старший регистр
		; nop
		; nop
		; nop
		; nop
		; nop
		; nop
		; nop
rjmp loop
;##############################################################################################
RESTART:
			clr DATA_STATUS
			clr BIT_COUNTER
			; cbi PORTD,4		; GREEN


			ret
;##############################################################################################
SAVE_BIT:	;Сохраняем бит "T" из регистра SREG как младший и сдвигаем весь буфер (8 байт = 64 бита) влево
			ldi zh,high(buffer)
			ldi zl,low(buffer)
			ldi r16,8
			adiw zl,9
			;скопируем пользовательский бит Т во флаг переноса С 
			clc
			brtc svbt_1
			sec
			;переберем по очереди все байты начиная с младшего и сдвинем все биты влево через "С"
	svbt_1:
			ld r17,-z
			rol r17
			st z,r17
			dec r16
			brne svbt_1
			ret
;##############################################################################################
;##############################################################################################
RFID_Int:	;(INT0) - вход импульсов от ридера RFID - по любому фронту
			sbrc RESIVER_MOD,7		;пропустить если нет ошибки приема по интервалам модулированного сигнала
			reti					;прием по прерываниям запрещен
			
			cp COUNTER_TAKT_4mks,MOD_LOW_SHORT	;сравнить с нижним пределом короткого интервала
			brpl RFID_go1		;перейти если нет минуса
			sbr RESIVER_MOD,0b10100000	;Ошибка приема по интервалам модулированного сигнала - интервал короче короткого
			cbr RESIVER_MOD,0b00000111	;Нет принятого интервала
			clr COUNTER_TAKT_4mks		;Сброс счетчика
			reti
	RFID_go1:
			cp COUNTER_TAKT_4mks,MOD_HIGH_SHORT	;сравнить с нижним пределом короткого интервала
			brpl RFID_go2		;перейти если нет минуса
			sbr RESIVER_MOD,0b00000101	;Принят short - Принят новый интервал
			cbr RESIVER_MOD,0b00000010	;Отмена long
			clr COUNTER_TAKT_4mks		;Сброс счетчика
			reti
	RFID_go2:
			cp COUNTER_TAKT_4mks,MOD_LOW_LONG	;сравнить с нижним пределом короткого интервала
			brpl RFID_go3		;перейти если нет минуса
			sbr RESIVER_MOD,0b10010000	;Ошибка приема по интервалам модулированного сигнала - интервал длинее короткого и короче длинного
			cbr RESIVER_MOD,0b00000111	;Нет принятого интервала
			clr COUNTER_TAKT_4mks		;Сброс счетчика
			reti
	RFID_go3:
			cp COUNTER_TAKT_4mks,MOD_HIGH_LONG	;сравнить с нижним пределом короткого интервала
			brpl RFID_go4		;перейти если нет минуса
			sbr RESIVER_MOD,0b00000011	;Принят long - Принят новый интервал
			cbr RESIVER_MOD,0b00000100	;Отмена short
			clr COUNTER_TAKT_4mks		;Сброс счетчика
			reti
	RFID_go4:
			sbr RESIVER_MOD,0b10001000	;Ошибка приема по интервалам модулированного сигнала - интервал длинее длинного
			cbr RESIVER_MOD,0b00000111	;Нет принятого интервала
			clr COUNTER_TAKT_4mks		;Сброс счетчика
			reti
;===============================================
OC0A_OVF:	;здесь каждые 4мкс (250кГц)
			sbrc RESIVER_MOD,7		;пропустить если нет ошибки приема по интервалам модулированного сигнала
			reti					;прием по прерываниям запрещен

			cp COUNTER_TAKT_4mks,r11
			breq OC0A_cnt_ovf
			inc COUNTER_TAKT_4mks
			reti
	OC0A_cnt_ovf:	;счетчик переполнен
			sbr RESIVER_MOD,0b11000000	;Переполнение счетчика COUNTER_TAKT_4mks
			cbr RESIVER_MOD,0b00000111	;Нет принятого интервала
			clr COUNTER_TAKT_4mks		;Сброс счетчика
			reti
;===============================================
			
			
			
		; mov r17,COUNTER_TAKT_4mks
		; rcall out_byte_RS232
			
			
			
			
	;RESIVER_MOD: 7бит - 1 = Общая ошибка приема по интервалам модулированного сигнала - прием по прерываниям запрещен; 0 = Все нормально
	;RESIVER_MOD: 6бит - 1 = Переполнение счетчика COUNTER_TAKT_4mks; 0 = Все нормально
	;RESIVER_MOD: 5бит - 1 = Ошибка приема по интервалам модулированного сигнала - интервал короче короткого; 0 = Все нормально
	;RESIVER_MOD: 4бит - 1 = Ошибка приема по интервалам модулированного сигнала - интервал длинее короткого и короче длинного; 0 = Все нормально
	;RESIVER_MOD: 3бит - 1 = Ошибка приема по интервалам модулированного сигнала - интервал длинее длинного; 0 = Все нормально
	
	;RESIVER_MOD: 2бит - 1 = Принят short (200-300mks)
	;RESIVER_MOD: 1бит - 1 = Принят long (400-600mks)
	;RESIVER_MOD: 0бит - 1 = Принят новый бит (в 0 сбрасывается обработчиком)
			
; Тогда короткий промежуток должен быть от 50 до 75 COUNTER_TAKT_4mks (от MOD_LOW_SHORT до MOD_HIGH_SHORT)
; а длинный от 100 до 150 COUNTER_TAKT_4mks (от MOD_LOW_LONG до r15)
			; mov r17,COUNTER_TAKT_4mks
			; ldi r17,0xCC
			; rcall out_byte_RS232

			; pop r17
	; clr COUNTER_L 	;обнулим счетчик тактовых импульсов 125кГц младший регистр
	; ; clr COUNTER_M
	; clr COUNTER_H 	;обнулим счетчик тактовых импульсов 125кГц старший регистр
			; cbi PORTD,4		; GREEN
			; sei





	; ; cli
			; cpi r24,255
			; brne tm0_1
			; cpi r25,255
			; breq tm0_2
	; tm0_1:		
			; adiw r24,1
			; ; brcc tm0_3
			; ; subi COUNTER_H,-1
			; ; inc 
			; ; rjmp tm0_4
			
			; ; inc COUNTER_L
	; ; tm0_4:		; inc COUNTER_M
			; ; brne tm0_3
			
			
	; ; tm0_3:	cbi PORTD,4		; GREEN
			; ; sei
			; reti

	; tm0_2:	;если счетчик уже переполнен
			; sbis PIND,4
			; sbi PORTD,4		; GREEN
			; sbic PIND,4
			; cbi PORTD,4		; GREEN
	; clr r24 	;обнулим счетчик тактовых импульсов 125кГц младший регистр
	; clr r25 	;обнулим счетчик тактовых импульсов 125кГц старший регистр
			; ; ; cpi COUNTER_L,255
			; ; brsh tm0_1		;перейти если равно или больше
			; ; inc COUNTER_L

	; ; tm0_1:
			; cpi COUNTER_L,255
			; brne tm0_1
			; ; cpi COUNTER_M,255
			; ; brne tm0_1
			; cpi COUNTER_H,255
			; breq tm0_2
	; tm0_1:		
			; inc COUNTER_L
			; brcc tm0_3
			; ; inc COUNTER_M
			; ; brcc tm0_3
			; inc COUNTER_H
			
	; tm0_3:	cbi PORTD,4		; GREEN
			; sei
			; reti

	; tm0_2:	;если счетчик уже переполнен
			; sbis PIND,4
			; sbi PORTD,4		; GREEN
			; sbic PIND,4
			; cbi PORTD,4		; GREEN
	; clr COUNTER_L 	;обнулим счетчик тактовых импульсов 125кГц младший регистр
	; clr COUNTER_M
	; clr COUNTER_H 	;обнулим счетчик тактовых импульсов 125кГц старший регистр
			; sei
; reti
;===============================================
; ;===============================================
; PCINT_Int:
			; sbrc STATUS,4	;пропустить если запрещена реакция по выводам (1)
			; reti
			
			; sbrc STATUS,3
			; rjmp pcint_sec			;если в режиме охраны
			
			; ; обычный режим
			; sbrs STATUS,7	;пропустить если идет начальная установка/проверка состояния SIM900
			; reti
			
			; cli
			; push r16
			
			; sbr STATUS,0b00010000	;блокируем выводы PB
				
			; rcall set_key_dat
			; out TCNT1H,r10
			; out TCNT1L,r10
			; ldi r16,0b00000011		; 0,125мкс*64*65536 = 524,288мс (переполнение счетчика)
			; out TCCR1B,r16

			; pop r16
			; sei
; reti
; ;--------
	; pcint_sec:
			; ; режим охраны
			; cli
			; out TCCR1B,r10		; Останавливаем 16 битный счетчик.
			; rcall set_key_dat
			; sei
; reti
; ;===============================================
out_byte_RS232:
			sbis UCSRA,UDRE
			rjmp out_byte_RS232
			out UDR,r17
ret
;===============================================
;===============================================
Receive_Int:	; обработка прерывания при поступлении очередного байта в приемник UART
			; sbrc STATUS,2		;пропустить буфер не занят
			; reti
			
			; cli
			; push zh
			; push zl
			push r17
			push r16

			; ; Останавливаем 8 битный счетчик.
			; out TCCR0B,r10

			in r16,UDR             ;Считать байт из регистра данных приемника
			mov r17,r16
			rcall out_byte_RS232
			; ;сохраним байт в буфере
			; ldi zh,high(buffer)
			; ldi zl,low(buffer)
			; ld r17,z   			;загрузим указатель буфера	
			; inc r17				;чтобы запись не началась на указатель
			; cpi r17,50			;если случился перебор
			; brne id01
			; clr r17
			; clr r16
	; id01:	st z,r17			;запишем указатель
			; add zl,r17
			; brcc id02
			; inc zh
	; id02:	st z,r16

			; ; Запускаем/перезапускаем 8 битный счетчик. Прерывание по переполнению.
			; out TCNT0,r10
			; ldi r16,0b00000011		; 0,125мкс*64*256 = 2,048мс (переполнение счетчика) а длительность байта 260мкс
			; out TCCR0B,r16

			pop r16
			pop r17
			; pop zl
			; pop zh
			; sei
reti
;===============================================
; ----------------------------------------------
;===============================================
; ----------------------------------------------
;БЛОК ЗАДЕРЖЕК		расчет задержек включает вход и выход из подпрограммы задержки
; (при f=8MHz такт=0,125мкс)
; (при f=16MHz такт=0,0625мкс)
; ----------------------------------------------
; d_sec:	;задержка по количеству секунд (r16)
		; rcall d_1000ms
		; dec r16
		; brne d_sec
; ret
; ----------------------------------------------
; d_100ms:
		; push r16
		; ldi r16,9
		; sts t1,r16
		; ldi r16,116
		; sts t2,r16
		; ldi r16,255
		; sts t3,r16
		; rcall delay
		; pop r16
		; ret
; ----------------------------------------------
; d_200ms:
		; push r16
		; ldi r16,9
		; sts t1,r16
		; ldi r16,232
		; sts t2,r16
		; ldi r16,255
		; sts t3,r16
		; rcall delay
		; pop r16
		; ret
; ----------------------------------------------
; d_500ms:
		; push r16
		; ldi r16,255
		; sts t1,r16
		; ldi r16,118
		; sts t2,r16
		; ldi r16,43
		; sts t3,r16
		; rcall delay
		; pop r16
		; ret
; ----------------------------------------------
; d_800ms:	; 3(rcall)+2+1+2+1+2+1+2+3(rcall)+[2+2+2+2+{ t1*(5+t2*(5+(t3*3-1))-1)-1 }+2+2+2+4(ret)]+2+4(ret) = X*T(0.125) = 
			; ; 41+{ t1*(5+t2*(5+(t3*3-1))-1)-1 } = 41+ 34*188504-1 = 6409176*0.125 = 801147мкс = 801,147мс
		; push r16	;2
		; ldi r16,34	;1
		; sts t1,r16	;2
		; ldi r16,250	;1
		; sts t2,r16	;2
		; ldi r16,250	;1
		; sts t3,r16	;2
		; rcall delay	;3
		; pop r16		;2
		; ret			;4
; ----------------------------------------------
; d_1000ms:		;1000,625mc
		; push r16
		; ldi r16,255
		; sts t1,r16
		; ldi r16,236
		; sts t2,r16
		; ldi r16,43
		; sts t3,r16
		; rcall delay
		; pop r16
		; ret
; ----------------------------------------------
;использование см. выше. минимум(1,1,1)= 41+{1*(5+1*(5+(1*3-1))-1)-1 } = 51*0.125 = 6.375мкс
; delay:	
		; push r13	;2
		; push r14	;2
		; push r15	;2
		; lds r15,t1	;2
; del3:	lds r14,t2	;2
; del2:	lds r13,t3	;2
; del1:	dec r13		;1
		; brne del1	;2/1
		; dec r14		;1
		; brne del2	;2/1
		; dec r15		;1
		; brne del3	;2/1
		; pop r15		;2
		; pop r14		;2
		; pop r13		;2
		; ret			;4
; ----------------------------------------------




