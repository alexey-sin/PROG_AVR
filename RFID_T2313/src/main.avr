;{ ;; ************************************************************************************* 
;; * Прошивка для контроллера ATTiny2313 репитер 
;; * транслятор байтов из PCF7991AT по RS232 и обратно
;; * 
;; * 
;; * КОНСТАНТЫ для EM4100
;; * Длительность промежутков протокола EM4100 может быть (1/Fclk)*64;(1/Fclk)*32;(1/Fclk)*16
;; * где Fclk = 125кГц. Допуск для чтения вообще примем середину меж временного интервала. Тогда
;; * Для (1/Fclk)*64 длительности будут 256(192-384) и 512(384-640)мкс
;; * Для (1/Fclk)*32 длительности будут 128(96-192) и 256(192-384)мкс
;; * Для (1/Fclk)*16 длительности будут 64(32-96) и 128(96-192)мкс
;; * Для подсчета интервалов будем использовать счетчик с периодом 4мкс
;; * Переполнение наступит 4*256=1024мкс
;; * Значения для каждого варианта будут:
;; * Для (1/Fclk)*64 48-96 и 96-160
;; * Для (1/Fclk)*32 24-48 и 48-96
;; * Для (1/Fclk)*16 8-24 и 24-48
;; * При попадании счетного значения на границу этих значений,
;; * а также значения меньше 8 и больше 160 - ошибка временных интервалов (таймингов)
;; * 
;; * 
;; * 
;; *************************************************************************************
;}
;; *************************************************************************************
.include "macros.avr"
.include "..\..\_AVR_ASSEMBLER\DEFs\tn2313def.inc"
.equ 	t1			=$60
.equ 	t2			=$61
.equ 	t3			=$62

;;=========================================================================================================
;; .eseg	;; EEPROM энергоНЕзависимая память 1024 байт
;; .org 0x000	;; EEPROM прошивать ненадо, эти номера контроллер запишет сам при настройке
;; ;; значения частот и шага записаны с младшего байта к старшему
;; eFstart:	.db 0x98,0x3A,0x00	;; стартовая частота 15000 (1500.0 кГц)
;; .org 0x003
;; eFstop:		.db 0xDF,0x93,0x04	;; конечная частота 299999 (29999.9 кГц)
;; .org 0x006
;; eFstep:		.db 0x64,0x00,0x00	;; шаг перестройки 100 (10.0 кГц)
;; .org 0x009
;; e:	.db 0x98,0x3A,0x00	;; 

;;=========================================================================================================
.dseg ;{	;сектор ОЗУ 1024 байт
.org 0x063
bf_RX:			.byte 17	;; буфер принятых байтов, первый байт - кол-во принятых байтов
bf_RFID_TMP:	.byte 10	;; буфер демодулированных данных временный
bf_RFID:		.byte 5	;; буфер демодулированных данных
RFID_READER:	.byte 5		;; группа байтов декодера
	;; RFID_READER[0]:	;; регистр статуса декодера
		;; RFID_READER[0]: 7бит - 1= Принят заголовок в манчестерском кодировании
		;; RFID_READER[0]: 6бит - значение прошлого принятого бита (для манчестерского кодирования)
		;; RFID_READER[0]: 5бит -
		;; RFID_READER[0]: 4бит -
		;; RFID_READER[0]: 3бит -
		;; RFID_READER[0]: 2бит - 
		;; RFID_READER[0]: 1бит - 
		;; RFID_READER[0]: 0бит - 
	;; RFID_READER[1]:	;; счетчик 4х битовых групп
	;; RFID_READER[2]:	;; счетчик бит заголовка, счетчик бит в группе из 4 бит
	;; RFID_READER[3]:	;; регистр 1 для временного хранения принятых бит
	;; RFID_READER[4]:	;; регистр 2 для временного хранения принятых бит
;}
;;=========================================================================================================
.def STATUS			= r15 ;{		;; регистр состояния
	;; STATUS: 7бит - 1 = Принято сообщение по RS232
	;; STATUS: 6бит - 1 = READ_TAG
	;; STATUS: 5бит - 1 = нечетный бит коротких интервалов
	;; STATUS: 4бит - 1 = буфер bf_RFID_INT заполнен, можно анализировать
	;; STATUS: 3бит - 1 = есть распознанный тайминг
	;; STATUS: 2бит - 1 = 
	;; STATUS: 1бит - 1 = 
	;; STATUS: 0бит - 1 = 
;}
.def ERROR			= r14 ;{		;; регистр ошибок
	;; ERROR: 7бит - 1= ($80) Переполнение буфера bf_RX
	;; ERROR: 6бит - 1= ($40) Неопознанная команда из ПК
	;; ERROR: 5бит - 1= ($20) 
	;; ERROR: 4бит - 1= ($10) 
	;; ERROR: 3бит - 1= ($08)
	;; ERROR: 2бит - 1= ($04)
	;; ERROR: 1бит - 1= ($02)
	;; ERROR: 0бит - 1= ($01)
;}	
.def RFID_INT		= r13		;; зарегистрированный модулированный интервал 
.def RFID_INT_BAND	= r12		;; тип принимаемых модулированных интервалов
	;; 1 - (1/Fclk)*16
	;; 2 - (1/Fclk)*32
	;; 3 - (1/Fclk)*64
;;=========================================================================================================
.cseg ;{	;; Таблица прерываний  - каждый адрес/ссылка = 2 байта
.org 0x0000		rjmp start
.org	INT0addr		reti	;; External Interrupt Request 0
.org	INT1addr		reti	;; External Interrupt Request 1
.org	ICP1addr		reti	;; Timer/Counter1 Capture Event
.org	OC1Aaddr		reti	;; Timer/Counter1 Compare Match A
.org	OVF1addr		reti	;; Timer/Counter1 Overflow (при переполнении счетчика(16бит))
.org	OVF0addr		rjmp Interrupt_OverFlow_80		;; Timer/Counter0 Overflow (при переполнении счетчика(8бит))
.org	URXCaddr		rjmp Interrupt_USART_RX_Complete	;; USART, Rx Complete (при возникновении прерывания RXC)
.org	UDREaddr		reti	;; USART Data Register Empty
.org	UTXCaddr		reti	;; USART, Tx Complete
.org	ACIaddr			reti	;; Analog Comparator
.org	PCIaddr			rjmp Interrupt_PCINT	;; при изменении сигналов на выводах PB0-7
.org	OC1Baddr		reti	;; 
.org	OC0Aaddr		reti	;; 
.org	OC0Baddr		reti	;; 
.org	USI_STARTaddr	reti	;; USI Start Condition
.org	USI_OVFaddr		reti	;; USI Overflow
.org	ERDYaddr		reti	;; 
.org	WDTaddr			reti	;; Watchdog Timer Overflow
;}	
;;=========================================================================================================
 ;{		;; Фьюзы
 ;; для F = 16 МГц (внешний кварц)
;; Фьюзы: для USBASP 1 => установленный бит => галки нет
;;					0 => сброшенный бит => отмечено галкой
;; все биты LOCK установлены
;;---- Fuse High Byte ----
;; DWEN - 1				(если V и LOCK не установлены влючается режим отладки debugWIRE через вывод RESET
;; EESAVE - 1
;; SPIEN - 0 (недоступен)
;; WDTON - 1
;; BODLEVEL2 - 1
;; BODLEVEL1 - 1
;; BODLEVEL0 - 1
;; RSTDISBL - 1
;;---- Fuse Low Byte ----
;; CKDIV8 - 1
;; CKOUT - 1
;; SUT1 - 1
;; SUT0 - 1
;; CKSEL3 - 1
;; CKSEL2 - 1
;; CKSEL1 - 1
;; CKSEL0 - 1
;;---- Fuse Extended Byte ----
;;
;; SELFPRGEN - 1
;}
;;=========================================================================================================
.org 0x018
start: ;{
	ldi r16,low(RAMEND)
	out spl,r16

	clr r10					;; R10 - 00000000
	ser r16
	mov r11,r16				;; R11 - 11111111
;;=========================================================================================================
;; Настройка портов => DDRx = 1(out); 0 = (in)   PORTx = 1(подтянут к +); 0(в воздухе - 0)
;; Порт A (-,-,-,-,-,2,1,0)
	;; ldi r16,0b00000011
	;; out DDRA,r16
	;; ldi r16,0b00000011
	;; out PORTA,r16

;; Порт B (7,6,5,4,3,2,1,0) PB7 - выход тактов USI(из МК); PB6 - выход данных USI(из МК); PB4 - вход данных USI(в МК)
	ldi r16,0b11000000
	out DDRB,r16
	ldi r16,0b00000000
	out PORTB,r16

;; Порт D (-,6,5,4,3,2,1,0)	PD2 - красный светодиод
;;							PD4 - зелёный светодиод
	ldi r16,0b00010100
	out DDRD,r16
	ldi r16,0b00000000
	out PORTD,r16
;;=========================================================================================================
;; Аналоговый компаратор		(Отключение 0b10000000 => ACSR)
	ldi r16,0b01000000
	out ACSR,r16
	ldi r16,0b00000010		;; Блокируем цифровой ввод по AIN1
	out DIDR,r16
;;=========================================================================================================
;; Настройка UART на 38400 bps(бод)
	out UBRRH,r10	;; предделитель старший разряд
	ldi r16,25		;; UBRR = 16000000/(16 * 38400) - 1 = 25,04 //при U2X = 0
	out UBRRL,r16	;; предделитель младший разряд
	out UCSRA,r10	;; ускоритель скорости на 2 выключим (U2X = 0 - 1 бит UCSRA)
	ldi r16,(1 << TXEN)|(1 << RXEN)|(1 << RXCIE)	;; вкл приемник(RXEN=1),вкл передатчик(TXEN=1),вкл прерывание по приему(RXCIE=1)
	out UCSRB,r16
	ldi r16,(3 << UCSZ0)	;; асинхронный режим(UMSEL=0), 8 бит(UCSZ2-0=011), 1 стоп-бит(USBS=0),без контроля четности(UPM1-0=00)
	out UCSRC,r16
;;=========================================================================================================
;; Прерывания таймеров
	ldi r16,(1 << TOIE0)		;; TOIE0 разрешить прерывание по переполнению 0(8разр) счетчика
	out TIMSK,r16				;; TOIE2 разрешить прерывание по переполнению 2(8разр) счетчика
;;=========================================================================================================
;; Прерывания по выводам PCINT7-0
	;;PCMSK будем управлять в тексте
	ldi r16,(1 << PCIE)		;; PCIE разрешить прерывание по выводам PCINT7-0
	out GIMSK,r16
	;; ldi r16,(1 << PCINT4)
	;; out PCMSK,r16
;;=========================================================================================================
;; инициализация буферов и переменных
	LdiX(bf_RX)
	st x,r10	 			;; обнулим счетчик принятых байтов (первый байт буфера)
	clr ERROR				;; очистим регистр ошибок
	clr STATUS				;; очистим регистр состояния
	clr RFID_INT
;;=========================================================================================================
	;; sbi PORTD,4 ;; GREEN	;; обмен с компьютером
	;; sbi PORTD,2 ;; RED	;; обмен с РС
	;; rcall d_500ms
	;; cbi PORTD,2 ;; RED
	;; cbi PORTD,4 ;; GREEN
;;=========================================================================================================
	;; rcall CheckEEpromValues

;; ldi r16,'S'
;; rcall Send_Byte_USART

;; rcall d_200ms
	sei
;; установим сразу тактовую частоту 8 МГц в RFID Reader'е
	LdiX(bf_RX)
	ldi r16,$01
	st x+,r16
	ldi r16,$71
	st x+,r16
	rcall AnalizRX
;; и установим сразу режим READ_TAG
;; rcall d_500ms
	LdiX(bf_RX)
	ldi r16,$01
	st x+,r16
	ldi r16,$E0
	st x+,r16
	rcall AnalizRX
;}
;;=========================================================================================================
loop: ;{
				tst ERROR
				breq lpNotERR ;{
				;; если произошна ошибка
					rcall SendERROR_E_PC
					sbi PORTD,2 ;; RED	;; ERROR
					rcall d_200ms
					cbi PORTD,2 ;; RED
					
					LdiX(bf_RX)
					st x,r10	 			;; обнулим счетчик принятых байтов (первый байт буфера)
					clr ERROR				;; очистим регистр ошибок
					clr STATUS				;; очистим регистр состояния
				;}
	lpNotERR:	;;=================================
				sbrc STATUS,7		;; пропустить если ненадо обрабатывать принятое сообщение по RS232
				rcall AnalizRX
		
				sbrs STATUS,6		;; READ_TAG
				rjmp lp_nRT
				;{ ;; режим READ_TAG
					tst RFID_INT
					breq lp_RT01
					rcall Analiz_TIMING_RFID
		lp_RT01:
					sbrc STATUS,3		;; есть распознанный тайминг
					rcall Analiz_READ_TAG
		
					sbrc STATUS,4		;; пропустить если ненадо анализировать буфер bf_RFID_INT
					rcall AnalizBUF_TIMING
				;}
	lp_nRT:
				;; sbi PORTB,7		;; SCLK
				;; nop
				;; nop
				;; nop
				;; nop
				;; cbi PORTB,7		;; SCLK
				
;; sbi PORTD,2 ;; RED
;; rcall SendERROR_PC	;;Посылка по RS232 "ERROR" (hex: 45 52 52 4F 52)

	;; sbi PORTD,4 ;; GREEN	;; обмен с компьютером
	;; sbi PORTD,2 ;; RED	;; обмен с РС
	;; rcall d_500ms
	;; cbi PORTD,2 ;; RED
	;; cbi PORTD,4 ;; GREEN
	;; rcall d_500ms
	;; rjmp 
	;; sbi PORTD,6 	;RED 2такта
			;; rcall d_1sec
			;;  ldi r16,0x55
			;;  rcall Send_Byte_USART
					
				 ;; sbrc STATUS,6		;; пропустить если ненадо обработать результат
				 ;; rcall Calculate


rjmp loop ;}
;;=========================================================================================================
AnalizRX: ;{	;; обработка принятого сообщения по RS232
				LdiX(bf_RX)
				ld r25,x+		;; кол-во принятых байтов в буфере
				ld r24,x+		;; загрузим первый (командный байт)
				
				cpi r25,1
				breq anlzrx_00
				rjmp anlzrx_m
	anlzrx_00:	;; принят один командный байт
				mov r16,r24
				andi r16,$E0
				cpi r16,$E0		;;0b111xxxxx = READ_TAG
				brne anlzrx_01
					LdiX(bf_RX)
					st x,r10
					SetBit STATUS,6		;; READ_TAG
					ClrBit STATUS,7		;; Принято сообщение по RS232
					sbi PORTD,4 ;; GREEN
					ldi r16,(1 << PCINT4)
					out PCMSK,r16
					rcall USI_SEND_3BITs
					clr RFID_INT
					clr RFID_INT_BAND
					LdiX(RFID_READER)	;;сброс статусного регистра декодера
					st x,r10
				rjmp anlzrx_exit
	anlzrx_01:
				mov r16,r24
				andi r16,$F0
				cpi r16,$10		;;0b0001xxxx = WRITE_TAG_N
				brne anlzrx_02
					mov r16,r24
					rcall USI_SEND_1Byte
				rjmp anlzrx_exit
	anlzrx_02:
				cpi r24,$08		;;0b00001000 = READ_PHASE
				brne anlzrx_03
					mov r16,r24
					rcall USI_SEND_AND_RECV_1Byte
				rjmp anlzrx_exit
	anlzrx_03:
				mov r16,r24
				andi r16,$C0
				cpi r16,$80		;;0b10xxxxxx = SET_SUMPLING_TIME
				brne anlzrx_04
					mov r16,r24
					rcall USI_SEND_1Byte
				rjmp anlzrx_exit
	anlzrx_04:
				cpi r24,$02		;;0b00000010 = GET_SUMPLING_TIME
				brne anlzrx_05
					mov r16,r24
					rcall USI_SEND_AND_RECV_1Byte
				rjmp anlzrx_exit
	anlzrx_05:
				mov r16,r24
				andi r16,$C0
				cpi r16,$40		;;0b01xxxxxx = SET_CONFIG_PAGE
				brne anlzrx_06
					mov r16,r24
					rcall USI_SEND_1Byte
				rjmp anlzrx_exit
	anlzrx_06:
				mov r16,r24
				andi r16,$FC
				cpi r16,$04		;;0b000001xx = GET_CONFIG_PAGE
				brne anlzrx_err
					mov r16,r24
					rcall USI_SEND_AND_RECV_1Byte
				rjmp anlzrx_exit
	anlzrx_m:	;; принятых байтов больше одного	
				mov r16,r24
				andi r16,$E0
				cpi r16,$C0		;;0b110xxxxx = WRITE_TAG
				brne anlzrx_err
				;; эту команду выполняем здесь
				;; SetBit CMD_USART,5	;; WRITE_TAG
				rjmp anlzrx_exit
	anlzrx_err:
				SetBit ERROR,6		;; Неопознанная команда из ПК
	anlzrx_exit:			
				LdiX(bf_RX)
				st x,r10
				ClrBit STATUS,7		;; Принято сообщение по RS232
ret ;}
Analiz_TIMING_RFID: ;{	;; определяет поддиапазон импульса и соответствие поддиапазона прошлого импульса
;; и аккумулирует сдвоенный короткий импульс
;; на выходе: STATUS,3 - принят импульс; бит Т = 1 - длинный, 0 - сдвоенный короткий
;; будем изначально исходить из того, что тайминг валиден
				SetBit STATUS,3			;; есть распознанный тайминг
				
				push r25
				push r24
				
				mov r25,RFID_INT
				mov r24,RFID_INT_BAND
				;; бит Т будет принятым битом
				cpi r25,24
				brcc anlztmrf_02
				;; short interval (1/Fclk)*16	RFID_INT_BAND = 1
					cpi r24,1
					breq anlztmrf_011
					;; Error band
					LdiX(RFID_READER)	;;сброс статусного регистра декодера
					ldi r16,1
					mov RFID_INT_BAND,r16
					rjmp anlztmrf_e
		anlztmrf_011:
					clt
					rjmp anlztmrf_10
	anlztmrf_02:
				cpi r25,48
				brcc anlztmrf_03
				;; long interval (1/Fclk)*16 or short interval (1/Fclk)*32	RFID_INT_BAND = 1,2(!=3)
					cpi r24,3
					brne anlztmrf_021
					;; Error band
					LdiX(RFID_READER)	;;сброс статусного регистра декодера
					ldi r16,1
					mov RFID_INT_BAND,r16
					rjmp anlztmrf_e
		anlztmrf_021:
					cpi r24,1
					brne anlztmrf_022
					set
					rjmp anlztmrf_10
		anlztmrf_022:
					clt
					rjmp anlztmrf_10
	anlztmrf_03:
				cpi r25,96
				brcc anlztmrf_04
				;; long interval (1/Fclk)*32 or short interval (1/Fclk)*64	RFID_INT_BAND = 2,3(!=1)
					cpi r24,1
					brne anlztmrf_031
					;; Error band
					LdiX(RFID_READER)	;;сброс статусного регистра декодера
					ldi r16,2
					mov RFID_INT_BAND,r16
					rjmp anlztmrf_e
		anlztmrf_031:
					cpi r24,2
					brne anlztmrf_032
					set
					rjmp anlztmrf_10
		anlztmrf_032:
					clt
					rjmp anlztmrf_10
	anlztmrf_04:
				;; long interval (1/Fclk)*64	RFID_INT_BAND = 3
					cpi r24,3
					breq anlztmrf_041
					;; Error band
					LdiX(RFID_READER)	;;сброс статусного регистра декодера
					ldi r16,3
					mov RFID_INT_BAND,r16
					rjmp anlztmrf_e
		anlztmrf_041:
					set
	anlztmrf_10:
				;; проверим четность короткого интервала
				brts anlztmrf_11		;; переход если длинный интервал
					sbrc STATUS,5		;; пропустить если нечетный бит коротких интервалов
					rjmp anlztmrf_11
					SetBit STATUS,5
					ClrBit STATUS,3			;; нет распознанного тайминга, это был нечетный короткий импульс
					rjmp anlztmrf_e
		anlztmrf_11:
					ClrBit STATUS,5
	anlztmrf_e:
				clr RFID_INT
				
				pop r24
				pop r25
ret ;}
Analiz_READ_TAG: ;{
;; Здесь мы имеем Т=1 дл.интервал; Т=0 кор.интервал (сдвоенный)
;; RFID_INT_BAND = текущий поддиапазон;

	;; МАНЧЕСТЕР
				LdiX(RFID_READER)
				ld r25,x+			;; регистр статуса декодера
				ld r24,x+			;; счетчик 4х битовых групп
				ld r23,x+			;; счетчик бит заголовка, счетчик бит в группе из 4 бит
				ld r22,x+			;; регистр 1 для временного хранения принятых бит
				ld r21,x+			;; регистр 2 для временного хранения принятых бит
				
				;; sbrc r25,7		;; если заголовок в манчестерском кодировании еще не принят
				;; rjmp anlzrtt_01
				;; ;{
					;; brts anlzrtt_02		;; переход если длинный интервал
					;; inc r23
					;; rjmp anlzrtt_em
		;; anlzrtt_02:	;; манчестер длинный интервал
					;; cpi r23,$08
					;; brne anlzrtt_03
					;; ;; конец заголовка, пришел первый нулевой бит тела
					;; ldi r25,0b11000000
					;; clr r24
					;; clr r23
					;; clr r22
					;; clr r21
					;; rjmp anlzrtt_01
		;; anlzrtt_03:	
					;; clr r23
					;; rjmp anlzrtt_em
				;; ;}
	;; anlzrtt_01:	;{ ;; манчестер после заголовка
					;; ;; работаем с пришедшим битом
					;; brtc anlzrtt_14		;; переход если кор.интервал
					;; ;; инвертируем бит M_STAT,6
					;; ldi r16,(1 << 6)
					;; eor r25,r16
		;; anlzrtt_14:	
					;; inc r23
					;; cpi r23,5
					;; breq anlzrtt_15
					;; clc
					;; sbrc r25,6
					;; sec
					;; rol r22
					;; rjmp anlzrtt_em
		;; anlzrtt_15:
					;; ;; проверяем четность
					;; cpi r24,10
					;; brne anlzrtt_20
					;; ;{ ;; пришел последний бит
						;; sbrs r25,6
						;; rjmp anlzrtt_16
						;; ;; ошибка - последний бит должен быть 0
						;; clr r25
						;; rjmp anlzrtt_em
			;; anlzrtt_16:
						;; ;;проверка последней группы - биты четности столбцов
						;; ldi r17,10
						;; LdiX(bf_RFID_TMP)
			;; anlzrtt_17:
						;; ld r16,x+
						;; eor r22,r16
						;; dec r17
						;; brne anlzrtt_17
						;; tst r22
						;; breq anlzrtt_18
						;; clr r25
						;; rjmp anlzrtt_em
				
			;; anlzrtt_18:
				
						;; ;; переносим с уплотнением принятые данные в окончательный буфер
						;; ldi r18,5
						;; LdiX(bf_RFID_TMP)
						;; LdiY(bf_RFID)
			;; anlzrtt_19:
						;; ld r17,x+
						;; swap r17
						;; ld r16,x+
						;; or r17,r16
						;; st y+,r17
						;; dec r18
						;; brne anlzrtt_19
						;; clr r25
						;; SetBit STATUS,4		;; буфер bf_RFID_TMP заполнен, можно анализировать
						;; rjmp anlzrtt_em
					;; ;}
		;; anlzrtt_20:
					;; ;; проверка бита четности текущей группы
					;; mov r18,r22
					;; clr r17
					;; sbrc r25,6
					;; inc r17			;; в r17 сейчас текущий пришедший бит четности
					;; ldi r19,4
		;; anlzrtt_21:
					;; clr r16
					;; ror r18
					;; rol r16
					;; eor r17,r16
					;; dec r19
					;; brne anlzrtt_21
					;; tst r17
					;; breq anlzrtt_22
					;; clr r25
					;; rjmp anlzrtt_em
					
		;; anlzrtt_22:
					;; ;; сохраняем байт в буфер
					;; LdiX(bf_RFID_TMP)
					;; add xl,r24
					;; adc xh,r10
					;; st x,r22
					
					;; clr r22
					;; clr r23
					;; inc r24
				
		;; anlzrtt_em:
				;; ;}
				;; sbrc r25,7		;; если заголовок в манчестерском кодировании еще не принят
				;; rjmp anlzrtt_e
	;; БИФАЗА
				clr r16
				brtc anlzrtt_26
				ser r16
	anlzrtt_26:
				rcall Send_Byte_USART
	
	
	anlzrtt_e:
				LdiX(RFID_READER)
				st x+,r25			;; регистр статуса декодера
				st x+,r24			;; счетчик 4х битовых групп
				st x+,r23			;; счетчик бит заголовка, счетчик бит в группе из 4 бит
				st x+,r22			;; регистр 1 для временного хранения принятых бит
				st x+,r21			;; регистр 2 для временного хранения принятых бит
			
				ClrBit STATUS,3			;; сброс распознанного тайминга
ret ;}
AnalizBUF_TIMING: ;{
				
				sbi PORTD,2 ;; RED
				ldi r18,5
				LdiX(bf_RFID)
	anlzbt_01:
				ld r16,x+
				rcall Send_Byte_USART
				dec r18
				brne anlzbt_01
				cbi PORTD,2 ;; RED
		
				
				ClrBit STATUS,4		;; сброс необходимости анализировать буфер bf_RFID_INT
ret ;}
Interrupt_USART_RX_Complete: ;{	;; обработка прерывания при поступлении очередного байта в приемник UART
				cli
				push r17
				pushX
				push r16
				in r16,SREG
				push r16
		
				out TCCR0B,r10		;; Останавливаем 8 битный счетчик.
				in r16,UDR          ;; Считать байт из регистра данных приемника
				
				sbrc STATUS,7		;; прошлое сообщение не обработано
				rjmp intusart_ext
				
				sbrs STATUS,6		;; READ_TAG
				rjmp intusart_01
				;; останавливаем режим READ_TAG
				sbi PORTB,7		;; SCLK
				out PCMSK,r10
				ClrBit STATUS,6
				cbi PORTD,4 	;; GREEN
				cbi PORTD,2 ;; RED
				rjmp intusart_ext
	intusart_01:
				;; сохраним байт в буфере
				LdiX(bf_RX)
				ld r17,x   			;; загрузим указатель буфера	
				inc r17				;; чтобы запись не началась на указатель
				cpi r17,16			;; если случился перебор
				breq intusart_ovf
				st x,r17			;; запишем указатель
				add xl,r17
				adc xh,r10
				st x,r16
				rjmp intusart_nxt
	intusart_ovf:
				SetBit ERROR,7		;; Переполнение буфера bf_RX
				rjmp intusart_ext
	intusart_nxt:	
				;; Запускаем/перезапускаем 8 битный счетчик. Прерывание по переполнению.
				;; ldi r16,(1 << PSR10)	;; сброс прескалера таймеров 1 и 0
				;; out GTCCR,r16
				out TCNT0,r10
				ldi r16,0b00000011		;; 0,0625мкс*64*256 = 1,024мс (переполнение счетчика) а длительность байта 260мкс
				;; ldi r16,0b00000100		;; 0,0625мкс*256*256 = 4,096мс (переполнение счетчика) а длительность байта 260мкс
				out TCCR0B,r16
	intusart_ext:
				pop r16
				out SREG,r16
				pop r16
				popX
				pop r17
				sei
reti ;}
Interrupt_OverFlow_80: ;{	;; время для приема очередного байта вышло - в буфере принята посылка
				cli
				push r16
				in r16,SREG
				push r16

				out TCCR0B,r10			;; стоп счетчик
				sbrc STATUS,6		;; READ_TAG
				rjmp intovf80_rt
				SetBit STATUS,7			;; Принято сообщение по RS232
				rjmp intovf80_e
	intovf80_rt:
				pushX
				LdiX(RFID_READER)	;;переполнение в режиме READ_TAG
				st x,r10
				popX
	intovf80_e:
				pop r16
				out SREG,r16
				pop r16
				sei
reti ;}
Interrupt_PCINT: ;{	;; прерывание по PB4 - вход данных USI(в МК)
				cli
				push r16
				in r16,SREG
				push r16

				sbrs STATUS,6		;; READ_TAG
				rjmp intrcint_e
				
				clr RFID_INT
				out TCCR0B,r10		;; Останавливаем 8 битный счетчик.
				in r16,TCNT0		;; загрузим кол-во насчитанных периодов по 4 мкс
				cpi r16,8			;; отсечем нижнюю границу
				brcs intrcint_ft
				cpi r16,24			;; граничное значение между таймингами
				breq intrcint_ft
				cpi r16,48			;; граничное значение между таймингами
				breq intrcint_ft
				cpi r16,96			;; граничное значение между таймингами
				breq intrcint_ft
				cpi r16,160			;; отсечем верхнюю границу
				brcc intrcint_ft
				
				mov RFID_INT,r16

	intrcint_ft:	;;fail timing
				out TCNT0,r10
				ldi r16,0b00000011		;; 0,0625мкс*64*256 = 1,024мс (переполнение счетчика) а длительность байта 260мкс
				out TCCR0B,r16
	intrcint_e:
				pop r16
				out SREG,r16
				pop r16
				sei
reti ;}
;;=========================================================================================================
.include "main_cont1.avr"
.include "delay16.avr"
;;=========================================================================================================






























