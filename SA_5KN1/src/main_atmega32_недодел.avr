;{ ************************************************************************************* 
;; * Прошивка для контроллера ATMega32 - тестирование радиостанции Р-168-5КН1 (далее РС)
;; * на настройку в сетке частот от 1500,0кГц до 29999,9кГц с любым шагом
;; * точностью до 0,1кГц.
;; * 	Устройство далее тестер АСУ.
;; * 	При включении РС с подключенным тестером АСУ он выжидает загрузки и инициализации РС,
;; * и начинает подавать команды на установку частоты и настройку РС на антенну.
;; * Результат настройки (да/нет) записывает во внешнюю память EEPROM 24LC512.
;; * 	При подключении к компьютеру (далее ПК) тестер АСУ автоматически определяет тип подключения
;; * и переходит в режим обмена с ПК.
;; *************************************************************************************
;; * 	Интерфейс обмена с ПК:
;; * XX - последний байт в посылке - сумма всех предыдущих - контроль целостности посылки
;; * Команда из ПК - PING - пинг (hex: 50 49 4E 47 XX) XX = 2E
;; * Ответ на пинг - (hex: 55 55 55 XX)
;; * Команда из ПК - GET FSTART - выдать стартовую частоту (hex: 47 45 54 20 46 53 54 41 52 54 XX) XX = D4
;; * Команда из ПК - GET FSTOP - выдать стартовую частоту (hex: 47 45 54 20 46 53 54 4F 50 XX)
;; * Команда из ПК - GET FSTEP - выдать стартовую частоту (hex: 47 45 54 20 46 53 54 45 50 XX)
;; * Ответы из тестера АСУ - FSTART 983A00 (hex: 46 53 54 41 52 54 20 98 3A 00 XX)
;; * Ответы на запрос FSTOP и FSTEP аналогичны.
;; * 
;; * Команда из ПК - SET FSTART 983A00 - установить стартовую частоту (hex: 53 45 54 20 46 53 54 41 52 54 20 98 3A 00 XX) XX = D2
;; * Ответы на установку - "ОК" (hex: 4F 4B XX) либо "ERROR" (hex: 45 52 52 4F 52 XX)
;; * 
;; * Команда из ПК - GET ERRORS - запрос ошибок последнего цикла проверки
;; * Ответ на запрос - ERRORS HH HH HH - число ошибок младшим байтом вперед
;; * и далее все ошибочные частоты в виде HH HH HH XX - частота младшим байтом вперед
;; * с интервалом 2мс
;; *************************************************************************************
;; * 	Интерфейс обмена с ПК: Р-168-5КН1
;; * Три кнопки: "Старт", "Пауза", "Стоп"
;; * Для начала сканирования нажать "Старт" (Fpause = 0) в КН посылаются команды:
;; *	>> 03 00 01 XX	(нажатие кнопки 1) чтоб станция перешла на 1 частоту канала
;; *		<< 03 00 88 XX		(принятая команда верная)
;; *		<< 03 00 77 XX		(принятая команда выполнена)
;; * либо	<< 03 00 66 XX		(принятая команда ошибочна или сбой)
;; *		<< FF 5D ...... 	(текстовый блок 256 байт)
;; * Пауза 500мс
;; *
;; *	Далее идут команды циклические с наращиванеим частоты на величину шага перестройки
;; *	>> 05 14 WW WW WW XX	(установка частоты - WW WW WW - c младшего байта)
;; *		<< 03 14 88 XX		(принятая команда верная)
;; *		<< 03 14 77 XX		(принятая команда выполнена)
;; * либо	<< 03 14 66 XX		(принятая команда ошибочна или сбой)
;; *		<< FF 5D ...... 	(текстовый блок 256 байт)
;; * Пауза 500мс
;; *	>> 03 00 01 XX	(нажатие кнопки 1) для того чтоб на станции высветилась частота
;; *		<< 03 00 88 XX		(принятая команда верная)
;; *		<< 03 00 77 XX		(принятая команда выполнена)
;; * либо	<< 03 00 66 XX		(принятая команда ошибочна или сбой)
;; *		<< FF 5D ...... 	(текстовый блок 256 байт)
;; * Пауза 500мс
;; *	>> 02 53 XX	(команда настройки АСУ)
;; *		<< 03 53 88 XX		(принятая команда верная)
;; *		<< 07 25 11 00 00 00 00 XX (нажата тон-вызов тангента)
;; *		<< 03 53 77 XX		(принятая команда выполнена)
;; * либо	<< 03 00 66 XX		(принятая команда ошибочна или сбой)
;; *		<< FF 5D 15(16)...... 	(текстовый блок 256 байт, третий байт 15 - АСУ настройка успешно, 16 - АСУ не настроено)
;; *		<< 07 25 00 00 00 00 00 XX (тон-вызов тангента отпущена)
;; * Пауза между настройками 500мс
;; * Далее цикл повторяется со следующей частотой
;; *
;; * Когда приходит текстовый блок с результатами настройки фиксируем если результат отрицательный
;; * - записываем инкременированное число ошибок в ячейку CntErrors и частоту во внеш. EEPROM
;; *
;; * При нажатии кнопки "Стоп" новый цикл не начинается Fpause = 0
;; * При нажатии кнопки "Пауза" новый цикл не начинается, следующая частота настройки записывается
;; * во внеш. EEPROM в ячейку Fpause.
;; *
;; * При нажатии кнопки "Пауза" в режиме ожидания если Fpause != 0 цикл возобновляется с частоты Fpause.
;; *************************************************************************************
;}
;; *************************************************************************************
.include "macros.avr"
.include "..\..\_AVR_ASSEMBLER\DEFs\m32def.inc"
.equ 	t1			=$60
.equ 	t2			=$61
.equ 	t3			=$62

;;=========================================================================================================
.eseg	;; EEPROM энергоНЕзависимая память 1024 байт
.org 0x000	;; EEPROM прошивать ненадо, эти номера контроллер запишет сам при настройке
;; значения частот и шага записаны с младшего байта к старшему
eFstart:	.db 0x98,0x3A,0x00	;; стартовая частота 15000 (1500.0 кГц)
.org 0x003
eFstop:		.db 0xDF,0x93,0x04	;; конечная частота 299999 (29999.9 кГц)
.org 0x006
eFstep:		.db 0x64,0x00,0x00	;; шаг перестройки 100 (10.0 кГц)
;; .org 0x009
;; e:	.db 0x98,0x3A,0x00	;; 

;;=========================================================================================================
.dseg ;{	;сектор ОЗУ 2048 байт
.org 0x063
buf_RX:		.byte 257	;; буфер принятых байтов, первый байт - кол-во принятых байтов
buf_TX:		.byte 33	;; буфер передаваемых байтов, первый байт - кол-во отправляемых байтов
i24Tmp1:	.byte 3		;; 24 битная переменная 
CurFreq:	.byte 3		;; текущая частота
;}
;;=========================================================================================================
.def MODE	= r9 ;{		;; регистр режимов работы
	;; MODE: 7бит - 1= режим обмена с ПК, 0= режим обмена с Р-168-5КН1
	;; MODE: 6бит - 1= 
	;; MODE: 5бит - 1= 
	;; MODE: 4бит - 1= 
	;; MODE: 3бит - 1= 
	;; MODE: 2бит - 1= 
	;; MODE: 1бит - 1= 
	;; MODE: 0бит - 1= резерв
;}	
.def ERROR	= r8 ;{		;; регистр ошибок
	;; ERROR: 7бит - 1= ($80)переполнение буфера buf_RX - пришел очередной байт а буфер полный
	;; ERROR: 6бит - 1= ($40)ошибка контрольной суммы в сообщении
	;; ERROR: 5бит - 1= ($20)ошибочная инструкция из ПК
	;; ERROR: 4бит - 1= ($10)ошибка обработки сообшения из радиостанции
	;; ERROR: 3бит - 1= 
	;; ERROR: 2бит - 1= 
	;; ERROR: 1бит - 1= 
	;; ERROR: 0бит - 1= резерв
;}	
.def STATUS	= r7 ;{		;; регистр состояния
	;; STATUS: 7бит - 1= принято сообщение по RS232 в буфер buf_RX и оно не обработано
	;; STATUS: 6бит - 1= прием сообщения 256 байт.(от приема первого байта 0xFF до конца обработки сообщения)
	;; STATUS: 5бит - 1= 
	;; STATUS: 4бит - 1= 
	;; STATUS: 3бит - 1= 
	;; STATUS: 2бит - 1= 
	;; STATUS: 1бит - 1= 
	;; STATUS: 0бит - 1= резерв
;}	
;;=========================================================================================================
.cseg ;{	;; Таблица прерываний 
.org 0x0000		rjmp start
.org INT0addr	reti		;;	= 0x0002	;; External Interrupt Request 0
.org INT1addr	reti		;;	= 0x0004	;; External Interrupt Request 1
.org INT2addr	reti		;;	= 0x0006	;; External Interrupt Request 2
.org OC2addr	reti		;;	= 0x0008	;; Timer/Counter2 Compare Match
.org OVF2addr	reti		;;	= 0x000a	;; Timer/Counter2 Overflow
.org ICP1addr	reti		;;	= 0x000c	;; Timer/Counter1 Capture Event
.org OC1Aaddr	reti		;;	= 0x000e	;; Timer/Counter1 Compare Match A
.org OC1Baddr	reti		;;	= 0x0010	;; Timer/Counter1 Compare Match B
.org OVF1addr	reti		;;	= 0x0012	;; Timer/Counter1 Overflow
.org OC0addr	reti		;;	= 0x0014	;; Timer/Counter0 Compare Match
.org OVF0addr	rjmp Interrupt_OverFlow_80	;;	= 0x0016	;; Timer/Counter0 Overflow
.org SPIaddr	reti		;;	= 0x0018	;; Serial Transfer Complete
.org URXCaddr	rjmp Interrupt_USART_RX_Complete	;;	= 0x001a	;; USART, Rx Complete
.org UDREaddr	reti		;;	= 0x001c	;; USART Data Register Empty
.org UTXCaddr	reti		;;	= 0x001e	;; USART, Tx Complete
.org ADCCaddr	reti		;;	= 0x0020	;; ADC Conversion Complete
.org ERDYaddr	reti		;;	= 0x0022	;; EEPROM Ready
.org ACIaddr	reti		;;	= 0x0024	;; Analog Comparator
.org TWIaddr	reti		;;	= 0x0026	;; 2-wire Serial Interface
.org SPMRaddr	reti		;;	= 0x0028	;; Store Program Memory Ready
;}	
;;=========================================================================================================
 ;{		;; Фьюзы
 ;; для F=8МГц (внутренний RC генератор)
;; Фьюзы: для USBASP 1 => установленный бит => галки нет
;;					0 => сброшенный бит => отмечено галкой
;; все биты LOCK установлены
;;---- Fuse High Byte ----
;; OCDEN - 1
;; JTAGEN - 1
;; SPIEN - 0 недоступен
;; CKOPT - 1
;; EESAVE - 1
;; BOOTSZ1 - 0
;; BOOTSZ0 - 0
;; BOOTRST - 1
;;---- Fuse Low Byte ----
;; BODLEVEL - 1
;; BODEN - 1
;; SUT1 - 1
;; SUT0 - 0
;; CKSEL3 - 0
;; CKSEL2 - 1
;; CKSEL1 - 0
;; CKSEL0 - 0
;}
;;=========================================================================================================
.org 0x030	;; для ATMEGA32 INT_VECTORS_SIZE	= 42 = 0x02A - размер поля для векторов прерывания
start: ;{
	ldi r16,low(RAMEND)
	out spl,r16
	ldi r16,high(RAMEND)
	out sph,r16

	clr r10					;; R10 - 00000000
	ser r16
	mov r11,r16				;; R11 - 11111111
;;=========================================================================================================
;; Настройка портов 
;; Порт A
	;; out DDRA,r11			;; все выводы работают как выход
	;; ;; ldi r16,0b10001110
	;; ;; out PORTA,r16
	;; out PORTA,r11

;; Порт B
	;; out DDRB,r11
	;; ldi r16,0b00000111
	;; out PORTB,r16

;; Порт C
	;; out DDRC,r11			;; все выводы работают как выход
	;; out PORTC,r10			;; без подтягивающих резисторов т.е. 0

;;  Порт D
;; PD0 RXD в МК
;; PD1 TXD из МК
;; PD2 INT0 
;; PD3 INT1 DSR в МК
;; PD4 DTR из МК
;; PD5 debug TXD из МК
;; PD6 выход на контрольный светодиод RED
;; PD7 выход на контрольный светодиод GREEN
	ldi r16,0b11110000
	out DDRD,r16
	ldi r16,0b00110000
	out PORTD,r16

;;=========================================================================================================
;; Настройка UART на 38400 bps(бод)
	out UBRRH,r10	;; предделитель старший разряд
	ldi r16,12		;; UBRR = 8000000/(16 * 38400) - 1 = 12,02 //при U2X = 0
	out UBRRL,r16	;; предделитель младший разряд
	ldi r16,(1 << RXEN)|(1 << TXEN)|(1 << RXCIE)	;; вкл приемник(RXEN=1),вкл передатчик(TXEN=1),вкл прерывание по приему(RXCIE=1)
	out UCSRB,r16
	;; Для доступа к регистру UCSRC ОБЯЗАТЕЛЬНО выставить бит URSEL!!!
	ldi r16,(1 << URSEL)|(3 << UCSZ0)	;; асинхронный режим(UMSEL=0), 8 бит(UCSZ2-0=011), 1 стоп-бит(USBS=0),без контроля четности(UPM1-0=00)
	out UCSRC,r16
;;=========================================================================================================
	;; ldi r16,0b00000110		;; установка прерываний по заднему фронту INT0
	;; out MCUCR,r16			;; или 0b00000110 по заднему фронту INT0 и любому изменению по INT1
	;; ldi r16,0b11000000		;; установка прерываний по INT0
	;; out GICR,r16			;; или 0b11000000 по заднему фронту INT0 и INT1

	ldi r16,0b00000001		;; 0b00000001 разрешить прерывание по переполнению 0(8разр) счетчика
	out TIMSK,r16			;; или 0b01000001 разрешить прерывание по переполнению 0(8разр) и 2(8разр) счетчиков
;;=========================================================================================================
;; инициализация буферов и переменных
	LdiX(buf_RX)
	st x,r10	 			;; обнулим счетчик принятых байтов (первый байт буфера)
	clr MODE				;; очистим регистр режимов работы
	clr ERROR				;; очистим регистр ошибок
	clr STATUS				;; очистим регистр состояния
;;=========================================================================================================
;; проверка линии DSR (ответ РС на активизацию RS232) до активизации RS232
	clt				;; сбросим флаг Т
	sbis PIND,3		;; DSR пропустить если бит в порту 1 (если вдруг порт РС не активен - нормально))
	set				;; установим флаг Т - порт РС не должен быть активен
	
	;; rcall d_5sec	;; время необходимое для загрузки РС
	;; rcall d_1sec	;; время необходимое для загрузки РС
	cbi PORTD,4		;; DTR (1=>0 переход в активное состояние) активизируем RS232
	rcall d_200ms	;; подождем
	;; проверим ответ РС
	sbic PIND,3		;; DSR пропустить если бит в порту 0 (1=>0 переход в активное состояние РС)
	set				;; установим флаг Т - нет ответа на активизацию порта РС
	brtc go0001		;; перейти если Т = 0 - все нормально и РС включила порт
	SetBit MODE,7	;; (7 бит)режим обмена с компьютером
	
go0001:	
	sbrc MODE,7	
	sbi PORTD,7 ;; GREEN	;; обмен с компьютером
	sbrs MODE,7
	sbi PORTD,6 ;; RED	;; обмен с РС

	rcall d_200ms
	cbi PORTD,6 ;; RED
	cbi PORTD,7 ;; GREEN
;;=========================================================================================================
	rcall CheckEEpromValues

;; ldi r16,'S'
;; rcall Debug_Send_Byte
;; ldi r16,'T'
;; rcall Debug_Send_Byte
;; ldi r16,'A'
;; rcall Debug_Send_Byte
;; ldi r16,'R'
;; rcall Debug_Send_Byte
;; ldi r16,'T'
;; rcall Debug_Send_Byte

;; cbi PORTD,6 ;RED 2такта
;; cbi PORTD,7 ;GREEN 2такта
	;; ClrBit MODE,7	;; (7 бит)режим обмена с Р-168-5КН1
	;; sbic UCSRA,RXC
	;; in r16,UDR
	sei
;}
;;=========================================================================================================
loop: ;{
				tst ERROR
				breq lp01
				sbi PORTD,6 ;RED	;; ERROR
				rcall d_200ms
				cbi PORTD,6 ;RED
				rcall d_200ms
				mov r16,ERROR
				rcall Send_Byte_USART
				clr ERROR
				LdiX(buf_RX)
				st x,r10
				rjmp loop
	lp01:
				sbrc MODE,7			;; проверка режима работы
				rjmp lp02
				
				;; Режим обмена с Р-168-5КН1
				sbrc STATUS,7		;; пропустить если нет принятого сообщение по RS232 в буфер buf_RX и оно не обработано
				rcall AnalizBuf_RX_RS
				rjmp loop
				
	lp02:		;; Режим обмена с ПК
				sbrc STATUS,7		;; пропустить если нет принятого сообщение по RS232 в буфер buf_RX и оно не обработано
				rcall AnalizBuf_RX_PC
				
				sbrs STATUS,6		;; прием сообщения 256 байт
				rjmp lp03
				;; в этом режиме этот флаг недопустим
				ClrBit STATUS,6
				LdiX(buf_RX)
				st x,r10
				SetBit ERROR,6
				
	lp03:
				
				rjmp loop
;; sbi PORTD,7 ;GREEN
;; rcall d_200ms
;; cbi PORTD,7 ;GREEN
				
;; sbi PORTD,6 ;RED
;; nop
;; nop
;; cbi PORTD,6 ;RED 2такта

	;; rjmp 
	;; sbi PORTD,6 	;RED 2такта
			;; rcall d_1sec
			;;  ldi r16,0x55
			;;  rcall Send_Byte_USART
					
		
				;;  sbrc RES_ST,3		;; пропустить если ненадо отправлять сообщение об ошибке - удержание линии TXD АСУ
				;;  rcall sendERR_RXD
		
				;;  sbrc RES_ST,2		;; пропустить если ненадо установить настройки генератора
				;;  rcall setGEN

				;;  sbrc RES_ST,1		;; пропустить если ненадо установить настройки усилителя мощности
				;;  rcall setUM

					;;  sbi PORTB,4
					;;  rcall d_200ms ; необходимо установить настройки генератора
					;;  cbi PORTB,4
					;;  rcall d_200ms
rjmp loop ;}
;;=========================================================================================================
AnalizBuf_RX_PC: ;{		;; анализ сообщений из компьютера
				sbi PORTD,7		;; GREEN
				ClrBit STATUS,7			;; (7 бит)сброс принятого сообщения по RS232 в буфер buf_RX
				rcall CheckSUMM
				tst ERROR
				breq alzpc01
				rjmp alzpc_exit
	alzpc01:	
				;; анализируем на ответ
				LdiZ(world_0 * 2)		;; "PING" готовность устройства
				rcall Compare_SubString
				tst r16					;; PING должен быть с 0 позиции
				brne alzpc02			;; если не совпало
					rcall AnswerPING_PC
					rjmp alzpc_exit
	alzpc02:	;{ ;; "SET" блок инструкций SET
				LdiZ(world_1 * 2)	;; "SET" блок инструкций SET
				rcall Compare_SubString
				tst r16					;; SET должен быть с 0 позиции
				breq alzpc021
				rjmp alzpc03			;; если не совпало
	alzpc021: ;{ ;; ========================================================
					LdiZ(world_3 * 2)	;; "FSTART" установка начальной частоты
					rcall Compare_SubString
					cp r16,r11				;; если 0xFF - не найдено
					breq alzpc031			;; если не найдено
						subi r16,-8			;; 6(длина "FSTART") + 1(пробел) + 1(байт индекса) = 8
						LdiX(buf_RX)
						AdrX r16
						LdiY(i24Tmp1)
						rcall Copy3_X_Y		;; переносит 3 байта с X -> Y и возвращает указатели на место
						
						LdiZ(constFreqMin * 2)	;; проверка на минимум
						rcall Compare3_Zm_Y	;; На выходе (УКАЗАТЕЛИ СБИТЫ!!!)флаги Z = 1 числа равны; N = 1 (Z < Y); если (Z > Y) флаги Z и N = 0.
						breq alzpc0312		;; Z = 1 т.е. Z = Y
						brmi alzpc0312		;; N = 1 т.е. Z < Y
						rcall SendERROR_PC
					rjmp alzpc_exit
			alzpc0312:	
						LdiZ(constFreqMax * 2)	;; проверка на максимум
						LdiY(i24Tmp1)
						rcall Compare3_Zm_Y	;; На выходе (УКАЗАТЕЛИ СБИТЫ!!!)флаги Z = 1 числа равны; N = 1 (Z < Y); если (Z > Y) флаги Z и N = 0.
						breq alzpc0313		;; Z = 1 т.е. Z = Y
						brpl alzpc0313		;; N = 0 т.е. Z > Y
						rcall SendERROR_PC
						rjmp alzpc_exit
			alzpc0313:	
						LdiX(i24Tmp1)
						LdiY(eFstart)
						rcall Copy3_X_Ye
						rcall SendOK_PC
						rjmp alzpc_exit
				;} ;; ========================================================
		alzpc031:;{ ;; ========================================================
					LdiZ(world_4 * 2)	;; "FSTOP" установка конечной частоты
					rcall Compare_SubString
					cp r16,r11				;; если 0xFF - не найдено
					breq alzpc032			;; если не найдено
						subi r16,-7			;; 5(длина "FSTOP") + 1(пробел) + 1(байт индекса) = 7
						LdiX(buf_RX)
						AdrX r16
						LdiY(i24Tmp1)
						rcall Copy3_X_Y		;; переносит 3 байта с X -> Y и возвращает указатели на место
						
						LdiZ(constFreqMin * 2)	;; проверка на минимум
						rcall Compare3_Zm_Y	;; На выходе (УКАЗАТЕЛИ СБИТЫ!!!)флаги Z = 1 числа равны; N = 1 (Z < Y); если (Z > Y) флаги Z и N = 0.
						breq alzpc0322		;; Z = 1 т.е. Z = Y
						brmi alzpc0322		;; N = 1 т.е. Z < Y
						rcall SendERROR_PC
					rjmp alzpc_exit
			alzpc0322:	
						LdiZ(constFreqMax * 2)	;; проверка на максимум
						LdiY(i24Tmp1)
						rcall Compare3_Zm_Y	;; На выходе (УКАЗАТЕЛИ СБИТЫ!!!)флаги Z = 1 числа равны; N = 1 (Z < Y); если (Z > Y) флаги Z и N = 0.
						breq alzpc0323		;; Z = 1 т.е. Z = Y
						brpl alzpc0323		;; N = 0 т.е. Z > Y
						rcall SendERROR_PC
						rjmp alzpc_exit
			alzpc0323:	
						LdiX(i24Tmp1)
						LdiY(eFstop)
						rcall Copy3_X_Ye
						rcall SendOK_PC
						rjmp alzpc_exit
				;} ;; ========================================================
		alzpc032:;{ ;; ========================================================
					LdiZ(world_5 * 2)	;; "FSTEP" установка шага перестройки частоты
					rcall Compare_SubString
					cp r16,r11				;; если 0xFF - не найдено
					brne alzpc033			;; если не найдено
					rjmp alzpc_err
			alzpc033:
						subi r16,-7			;; 5(длина "FSTEP") + 1(пробел) + 1(байт индекса) = 7
						LdiX(buf_RX)
						AdrX r16
						LdiY(i24Tmp1)
						rcall Copy3_X_Y		;; переносит 3 байта с X -> Y и возвращает указатели на место
						
						LdiZ(constStepMin * 2)	;; проверка на минимум
						rcall Compare3_Zm_Y	;; На выходе (УКАЗАТЕЛИ СБИТЫ!!!)флаги Z = 1 числа равны; N = 1 (Z < Y); если (Z > Y) флаги Z и N = 0.
						breq alzpc0332		;; Z = 1 т.е. Z = Y
						brmi alzpc0332		;; N = 1 т.е. Z < Y
						rcall SendERROR_PC
					rjmp alzpc_exit
			alzpc0332:	
						LdiZ(constStepMax * 2)	;; проверка на максимум
						LdiY(i24Tmp1)
						rcall Compare3_Zm_Y	;; На выходе (УКАЗАТЕЛИ СБИТЫ!!!)флаги Z = 1 числа равны; N = 1 (Z < Y); если (Z > Y) флаги Z и N = 0.
						breq alzpc0333		;; Z = 1 т.е. Z = Y
						brpl alzpc0333		;; N = 0 т.е. Z > Y
						rcall SendERROR_PC
						rjmp alzpc_exit
			alzpc0333:	
						LdiX(i24Tmp1)
						LdiY(eFstep)
						rcall Copy3_X_Ye
						rcall SendOK_PC
						rjmp alzpc_exit
				;} ;; ========================================================
			;}
	alzpc03:	;{ ;; "GET" блок инструкций GET
				LdiZ(world_2 * 2)	;; "GET" блок инструкций GET
				rcall Compare_SubString
				tst r16					;; GET должен быть с 0 позиции
				breq alzpc040
				rjmp alzpc_err			;; если не совпало
		alzpc040:
					LdiZ(world_3 * 2)	;; "FSTART" запрос начальной частоты
					rcall Compare_SubString
					cp r16,r11				;; если 0xFF - не найдено
					breq alzpc041			;; если не совпало
					;{
						LdiX(buf_TX)
						st z,r10
						LdiZ(world_3 * 2)	;; "FSTART"
						clr r16
						rcall BufferCatString_Zm_X
						LdiZ(world_space * 2)	;; пробел
						rcall BufferCatString_Zm_X
						LdiY(eFstart)
						rcall BufferCat3_Ye_X
						rcall SetCheckSummTX
						rcall SendTX

					;}
					rjmp alzpc_exit
		alzpc041:
					LdiZ(world_4*2)	;; "FSTOP" запрос конечной частоты
					rcall Compare_SubString
					cp r16,r11				;; если 0xFF - не найдено
					breq alzpc042			;; если не совпало
					;{
						LdiX(buf_TX)
						st z,r10
						LdiZ(world_4 * 2)	;; "FSTOP"
						clr r16
						rcall BufferCatString_Zm_X
						LdiZ(world_space * 2)	;; пробел
						rcall BufferCatString_Zm_X
						LdiY(eFstop)
						rcall BufferCat3_Ye_X
						rcall SetCheckSummTX
						rcall SendTX

					;}
					rjmp alzpc_exit
		alzpc042:
					LdiZ(world_5*2)	;; "FSTEP" запрос шага перестройки
					rcall Compare_SubString
					cp r16,r11				;; если 0xFF - не найдено
					breq alzpc043			;; если не совпало
					;{
						LdiX(buf_TX)
						st z,r10
						LdiZ(world_5 * 2)	;; "FSTEP"
						clr r16
						rcall BufferCatString_Zm_X
						LdiZ(world_space * 2)	;; пробел
						rcall BufferCatString_Zm_X
						LdiY(eFstep)
						rcall BufferCat3_Ye_X
						rcall SetCheckSummTX
						rcall SendTX

					;}
					rjmp alzpc_exit
		alzpc043:
					LdiZ(world_6*2)	;; "ERRORS" запрос ошибок последнего цикла настройки
					rcall Compare_SubString
					cp r16,r11				;; если 0xFF - не найдено
					breq alzpc_err			;; если не совпало
					;; ------
					rjmp alzpc_exit
				;}
	alzpc_err:
				SetBit ERROR,5	;; (5 бит)ошибочная инструкция из ПК
	alzpc_exit:
				;; сообщение обработано, очистим счетчик
				LdiZ(buf_RX)
				st z,r10
				cbi PORTD,7		;; GREEN
ret ;}
AnalizBuf_RX_RS: ;{		;; анализ сообщений из радиостанции
				push r25
				sbi PORTD,6 		;; RED
				ClrBit STATUS,7			;; (7 бит)сброс принятого сообщения по RS232 в буфер buf_RX
				rcall CheckSUMM
				tst ERROR
				breq alzrs01
				rjmp alzrs_exit
	alzrs01:	
				LdiX(buf_RX)
				ld r25,x+
				cpi r25,4
				brne alzrs02
				;{ ;; получено сообщение длиной 4 байта
					;; получен ответ на отправленную команду (0x03). проверим первый байт, указатель X уже на нём.
					ld r16,x+
					cpi r16,$03
					breq alzrs0101
					rjmp alzrs_err
					;; формат сообщения: $03 $CC $MM $XX
					;; где: $CC - номер команды; $MM - сообщение; $XX - контрольная сумма
		alzrs0101:
					
					
					
				;}
				rjmp alzrs_exit
	alzrs02:			
				cpi r25,91
				brne alzrs03
				;{ ;; получено сообщение длиной 91 байт
					;; получен пакет 91 байт с радиоданными
					;; проверим первый байт, указатель X уже на нём.
					ld r16,x+
					cpi r16,$5A
					breq alzrs0201
					rjmp alzrs_err
		alzrs0201:
					;; это сообщение просто пропускаем
				;}
				rjmp alzrs_exit
	alzrs03:			
				cpi r25,8
				brne alzrs04
				;{ ;; получено сообщение длиной 8 байт
					;; сообщение о состоянии тангенты [07 25 VV 00 00 00 00 XX] => VV: 01 - нажата тангента; 11 - нажат тон/вызов; 00 - ничего не нажато.
					;; проверим первые 2 байта, указатель X уже на первом.
					ld r16,x+
					cpi r16,$07
					breq alzrs0301
					rjmp alzrs_err
		alzrs0301:
					ld r16,x+
					cpi r16,$25
					breq alzrs0302
					rjmp alzrs_err
		alzrs0302:
					;; это сообщение просто пропускаем
				;}
				rjmp alzrs_exit
	alzrs04:			
				cpi r25,0
				brne alzrs_err
				sbrs STATUS,6			;; прием сообщения 256 байт.
				rjmp alzrs_err
				ClrBit STATUS,6			;; сбросим бит (прием сообщения 256 байт), он больше не нужен
				;{ ;; получено сообщение длиной 256 байт
				
					rcall SendOK_PC

				;}
				rjmp alzrs_exit
	alzrs_err:
				SetBit ERROR,4	;; (4 бит)ошибка обработки сообшения из радиостанции
	alzrs_exit:
				;; сообщение обработано, очистим счетчик
				LdiZ(buf_RX)
				st z,r10
				cbi PORTD,6 		;; RED
				pop r25
ret ;}
Interrupt_USART_RX_Complete: ;{	;; обработка прерывания при поступлении очередного байта в приемник UART
				cli
				push r17
				push r16
				pushX
				in r16,SREG
				push r16
				
				out TCCR0,r10	;; стоп счетчик
				in r16,UDR

				tst ERROR
				brne ovr01
				
				sbrc STATUS,7		;; (7 бит)принято сообщение по RS232 в буфер buf_RX и оно не обработано
				rjmp ovr01			;; прошлое сообщение еще не обработано
				
				LdiZ(buf_RX)
				ld r17,z  			;; загрузим счетчик буфера	
				;;проверка па первый байт 0xFF
				tst r17
				brne ovr03			;; не первый байт
				cpi r16,$FF
				brne ovr03			;; не тот байт
				SetBit STATUS,6		;; (6 бит)прием сообщения 256 байт.(от приема первого байта 0xFF до конца обработки сообщения)
	ovr03:
				inc r17
				brne ovr02			;; проверка на 0 (значит был 0xFF - максимум)
				;; если случился перебор
				sbrc STATUS,6		;; (6 бит)прием сообщения 256 байт.(значит это последний байт)
				rjmp ovr02
				SetBit ERROR,7		;; (7 бит)переполнение буфера
				clr r17
				clr r16
				rjmp ovr01
	ovr02:	
				st z,r17			;; запишем указатель
				AdrZ r17
				tst r17
				brne ovr04
				sbrs STATUS,6		;; (6 бит)прием сообщения 256 байт.
				rjmp ovr04
				adiw zl,63			;;поскольку r17=0 здесь надо прирастить 256 для записи последнего байта
				adiw zl,63			;; 63 это максимум для 6 бит
				adiw zl,63
				adiw zl,63
				adiw zl,4
	ovr04:
				st z,r16			;; запишем принятый байт
				;; запуск счетчика
				out TCNT0,r10		;; обнулим счетчик таймера
				ldi r16,0b00000011	;; (такт = 0,125мкс) * 64 * 256 = 2.048 мс
				out TCCR0,r16		;; пуск счетчик
	ovr01:		
				pop r16
				out SREG,r16
				popX
				pop r16
				pop r17
				sei
reti ;}
Interrupt_OverFlow_80: ;{	;; время для приема очередного байта вышло - в буфере принята посылка
				cli
				push r16
				in r16,SREG
				push r16

				out TCCR0,r10			;; стоп счетчик
					
				SetBit STATUS,7			;;(7 бит)принято сообщение по RS232 в буфер buf_RX и оно не обработано

				pop r16
				out SREG,r16
				pop r16
				sei
reti ;}
;;=========================================================================================================
.include "main_cont1.avr"
.include "delay.avr"
;;=========================================================================================================






























