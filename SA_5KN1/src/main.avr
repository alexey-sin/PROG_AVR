;{ ;; Описание работы сканера и протоколов обмена
;; ************************************************************************************* 
;; * Прошивка для контроллера ATMega8 - тестирование радиостанции Р-168-5КН1 (далее РС)
;; * на настройку в сетке частот от 1500,0кГц до 29999,9кГц с любым шагом
;; * точностью до 0,1кГц.
;; * 	Устройство далее тестер АСУ.
;; * 	При включении РС с подключенным тестером АСУ он выжидает загрузки и инициализации РС,
;; * и начинает подавать команды на установку частоты и настройку РС на антенну.
;; * Результат настройки (да/нет) записывает во внешнюю память EEPROM 24LC512.
;; * 	При подключении к компьютеру (далее ПК) тестер АСУ автоматически определяет тип подключения
;; * и переходит в режим обмена с ПК.
;; *************************************************************************************
;; * 	Интерфейс обмена с ПК:
;; * XX - последний байт в посылке - сумма всех предыдущих - контроль целостности посылки
;; * Команда из ПК - (hex: 50 50) "P" - пинг; Ответ - (hex: 55 55 55 FF)
;; * 
;; * блок инструкций GET
;; * Команда из ПК - (hex: 47 01 48) - выдать стартовую частоту ("eeFstart"); Ответ - (hex: 46 01 QQ QQ QQ XX)
;; * Команда из ПК - (hex: 47 02 49) - выдать конечную частоту ("eeFstop"); Ответ - (hex: 46 02 QQ QQ QQ XX)
;; * Команда из ПК - (hex: 47 03 4A) - выдать шаг перестройки ("eeFstep"); Ответ - (hex: 46 03 QQ QQ QQ XX)
;; * Команда из ПК - (hex: 47 EE 35) - выдать ошибки работы сканера; Ответ - (hex: EE RR RR RR RR RR RR RR RR XX) 
;; * 		где RR - рабочие регистры сохраненные во внутр. EEPROM (eDEBUG_INFO) во время последней ошибки
;; * Команда из ПК - (hex: 47 0E 55) - выдать ошибки сканирования; 
;; * 		Ответ - (hex: CE RR RR XX) RR - число ошибок
;; * 				(hex: FE QQ QQ QQ XX) QQ - конечная частота сканирования
;; * 		и далее все ошибочные частоты в виде (hex: EF HH HH HH XX) - частота младшим байтом вперед
;; * 
;; * блок инструкций SET
;; * Команда из ПК - (hex: 53 01 QQ QQ QQ XX) - установить стартовую частоту
;; * Команда из ПК - (hex: 53 02 QQ QQ QQ XX) - установить конечную частоту
;; * Команда из ПК - (hex: 53 03 QQ QQ QQ XX) - установить шаг перестройки
;; * Ответы на установку - "ОК" (hex: 4F 4B XX) либо "ERROR" (hex: 45 52 52 4F 52 XX)
;; * 
;; * Из сканера в режиме обмена с компьютером при нажатии "Старт" отсылка в ПК команды
;; * "I want to give data" - хочу выдать данные (для получения запроса всех GET)
;; * формат: (hex: 49 57 54 47 44 7F) "IWTGD"
;; *************************************************************************************
;; * 	Интерфейс обмена с Р-168-5КН1: 
;; * Три кнопки: "Старт", "Пауза", "Стоп"
;; * Для начала сканирования нажать "Старт" (Fpause = 0) в КН посылаются команды:
;; *	>> 03 00 01 XX	(нажатие кнопки 1) чтоб станция перешла на 1 частоту канала
;; *		<< 03 00 88 XX		(принятая команда верная)
;; *		<< 03 00 77 XX		(принятая команда выполнена)
;; * либо	<< 03 00 66 XX		(принятая команда ошибочна или сбой)
;; *		<< FF 5D ...... 	(текстовый блок 256 байт)
;; * Пауза 500мс
;; *
;; *	Далее идут команды циклические с наращиванеим частоты на величину шага перестройки
;; *	>> 05 14 WW WW WW XX	(установка частоты - WW WW WW - c младшего байта)
;; *		<< 03 14 88 XX		(принятая команда верная)
;; *		<< 03 14 77 XX		(принятая команда выполнена)
;; * либо	<< 03 14 66 XX		(принятая команда ошибочна или сбой)
;; *		<< FF 5D ...... 	(текстовый блок 256 байт)
;; * Пауза 500мс
;; *	>> 03 00 01 XX	(нажатие кнопки 1) для того чтоб на станции высветилась частота
;; *		<< 03 00 88 XX		(принятая команда верная)
;; *		<< 03 00 77 XX		(принятая команда выполнена)
;; * либо	<< 03 00 66 XX		(принятая команда ошибочна или сбой)
;; *		<< FF 5D ...... 	(текстовый блок 256 байт)
;; * Пауза 500мс
;; *	>> 02 53 XX	(команда настройки АСУ)
;; *		<< 03 53 88 XX		(принятая команда верная)
;; *		<< 07 25 11 00 00 00 00 XX (нажата тон-вызов тангента)
;; *		<< 03 53 77 XX		(принятая команда выполнена)
;; * либо	<< 03 53 66 XX		(принятая команда ошибочна или сбой)
;; *		<< FF 5D 15(16)...... 	(текстовый блок 256 байт, третий байт 15 - АСУ настройка успешно, 16 - АСУ не настроено)
;; *		<< 07 25 00 00 00 00 00 XX (тон-вызов тангента отпущена)
;; *		<< 5A ...... (блок радиоданных 91 байт)
;; * Пауза между настройками 500мс
;; * Далее цикл повторяется со следующей частотой
;; *
;; * Когда приходит текстовый блок с результатами настройки фиксируем если результат отрицательный
;; * - записываем инкременированное число ошибок в ячейку CntErrors и частоту во внеш. EEPROM
;; *
;; * При нажатии кнопки "Стоп" новый цикл не начинается Fpause = 0
;; * При нажатии кнопки "Пауза" новый цикл не начинается, следующая частота настройки записывается
;; * во внеш. EEPROM в ячейку Fpause.
;; *
;; * При нажатии кнопки "Пауза" в режиме ожидания если Fpause != 0 цикл возобновляется с частоты Fpause.
;; *************************************************************************************
;}
;; *************************************************************************************
.include "macros.avr"
.include "..\..\_AVR_ASSEMBLER\DEFs\m8def.inc"
.equ 	t1			=$60
.equ 	t2			=$61
.equ 	t3			=$62

;;=========================================================================================================
;{;;  	EEPROM энергоНЕзависимая память 512 байт
.eseg
.org 0x000	;; EEPROM прошивать ненадо, эти данные контроллер запишет сам при работе
eDEBUG_INFO:	.db 0,0,0,0,0,0,0,0	;; 8 байт: STATUS,ERROR,ANS_RS_COM,ANS_RS_VAL,STEP_CYKL,ANS_RS_CNT,ANS_RS_SUM,'E' - записываются в случае ошибки
;; ;; значения частот и шага записаны с младшего байта к старшему
;; eFstart:	.db 0x98,0x3A,0x00	;; стартовая частота 15000 (1500.0 кГц)
;; .org 0x003
;; eFstop:		.db 0xDF,0x93,0x04	;; конечная частота 299999 (29999.9 кГц)
;; .org 0x006
;; eFstep:		.db 0x64,0x00,0x00	;; шаг перестройки 100 (10.0 кГц)
;; .org 0x009
;; e:	.db 0x98,0x3A,0x00	;; 
;}
;;=========================================================================================================
;; Карта патяти внешней EEPROM 24LC512 - 512K бит (64К*8) 64К байт, или 21845 трехбайтных чисел
;; Таблица значений: МЕТКА = адрес памяти
;; Переменные 3х байтные
.equ eeFstart		= $0000
.equ eeFstop		= $0003
.equ eeFstep		= $0006
.equ eeERR_CNT		= $0009	;; счетчик ошибок.поле 3х байтное,но используется 2 байта и то только до 21758(вкл)
.equ eeFREQ_END		= $000C	;; частота на которой фактически закончилось предыдущее сканирование
.equ eeFREQS_ERR	= $0100	;; поле частот (по 3 байта на частоту) с ошибками настроек

;; значение eeERR_CNT возможно до: $FFFF(макс.адрес EEPROM) $0100 = 21758 т.е. последний адрес $FFFA
;;=========================================================================================================
.dseg ;{	;сектор ОЗУ 1024 байт
.org 0x063
buf_TX:		.byte 16	;; буфер передаваемых байтов, первый байт - кол-во отправляемых байтов
i24Tmp1:	.byte 3		;; 24 битная переменная 
i24Tmp2:	.byte 3		;; 24 битная переменная 
i24TmpRS:	.byte 3		;; 24 битная переменная для приема/передачи по USART
CurFreq:	.byte 3		;; текущая частота
;}
;;=========================================================================================================
.def STATUS	= r15 ;{		;; регистр состояния
	;; STATUS: 7бит - 1= режим обмена с ПК, 0= режим обмена с Р-168-5КН1
	;; STATUS: 6бит - 1= принято сообщение по RS232 в регистрах ANS_RS_COM и ANS_RS_VAL
	;; STATUS: 5бит - 1= ждем приема сообщения 256 байт о настройке АСУ
	;; STATUS: 4бит - работа 16бит. таймера: 1= ожидание ответа радиостанции 0 - задержка в цикле сканирования
	;; STATUS: 3бит - 1= конец задержки 16бит. таймера в цикле сканирования
	;; STATUS: 2бит - 1= 
	;; STATUS: 1бит - 1= пауза (P)
	;; STATUS: 0бит - 1= запущено сканирование (S)
;}	
.def ERROR	= r14 ;{		;; регистр ошибок
;;  Для режима обмена с компьютером
	;; ERROR: 7бит - 1= ($80)ошибка контрольной суммы в сообщении
	;; ERROR: 6бит - 1= ($40)ошибка распознавания сообщения принятого по RS232
	;; ERROR: 5бит - 1= ($20)прием байта по RS232 при необработанном прошлом сообщении
	;; ERROR: 4бит - 1= ($10)ошибка - неопознанная инструкция
	;; ERROR: 3бит - 1= ($08)ошибка - необработанные данные принятые по RS232
	;; ERROR: 2бит - 1= ($04)ошибка - чтение/запись во внешнее EEPROM
	;; ERROR: 1бит - 1= ($02)ошибка - переполнение EEPROM
	;; ERROR: 0бит - 1= ($01)ошибка - время для ответа радиостанции вышло
		;;  Смешанные значения
	;; ERROR: 1,0бит($03) ошибка - получен ответ $66
													;; ERROR: 6бит - 1= ($40)ошибка распознавания сообщения принятого по RS232
													;; ERROR: 5бит - 1= ($20)
													;; ERROR: 4бит - 1= ($10)
													;; ERROR: 3бит - 1= ($08)ошибка - переполнение EEPROM
													;; ERROR: 2бит - 1= ($04)ошибка - чтение/запись во внешнее EEPROM
													;; ERROR: 1бит - 1= ($02)ошибка - нарушение порядка цикла
													;; ERROR: 0бит - 1= ($01)ошибка - время для ответа радиостанции вышло
	
;}	
.def ANS_RS_COM	= r13 ;{		;; тип сообщения принятое по RS232 от радиостанции
;;  Для режима обмена с компьютером
;; 		$50 - принят запрос "PING"
;; 		$47 - принят запрос "PING"
;;  Для режима обмена с радиостанцией
;; 		$03 - ответ на команду
;; 		$07 - состояние тангенты
;; 		$5A - блок радиоданных
;; 		$FF - текстовая посылка 256 байт - результат настройки АСУ (если третьим байтом будет $15 или $16)
;}	
.def ANS_RS_VAL	= r12 ;{		;; тип значение сообщения принятое по RS232 от радиостанции
;;  Для режима обмена с компьютером
;; 		ANS_RS_COM = $50	ANS_RS_VAL = $00
;; 		ANS_RS_COM = $47	ANS_RS_VAL = $01,$02,$03,$04
;; 		ANS_RS_COM = $53	ANS_RS_VAL = $01,$02,$03 и используется i24TmpRS
;;  Для режима обмена с радиостанцией
;;  	Для ANS_RS_COM = $03
;;  		7-4биты - тип подкоманды на которую получен ответ
;;				0000($0-) подкоманда 00 ответ на команду нажатия кнопки
;;				0100($4-) подкоманда 14 ответ на команду смены частоты текущего канала 
;;				0011($3-) подкоманда 53 ответ на команду настройки АСУ
;;			3-0биты - значение ответа
;; 				0110 ($-6) 66 ошибка команды или ошибка выполнения
;; 				0111 ($-7) 77 принятая команда выполнена
;; 				1000 ($-8) 88 принятая команда верная, идет выполнение
;;  	Для ANS_RS_COM = $07 и $5A ANS_RS_VAL = $00
;;  	Для ANS_RS_COM = $FF 
;; 				$16 АСУ не настроено
;; 				$15 АСУ настроено
;}	
.def ANS_RS_CNT	= r9 ;{		;; счетчик байтов в сообщении (вместе с байтом контрольной суммы)
;;  Для режима обмена с компьютером
	;; для ANS_RS_COM:	$50	=	5
	;;					$47	=	3
	;;					$53	=	6
;;  Для режима обмена с радиостанцией
	;; для ANS_RS_COM:	$03	=	4
	;;					$07	=	8
	;;					$5A	=	91
	;;					$FF	=	256(0)
;}	
.def ANS_RS_SUM	= r8		;; контрольная сумма сообщения
.def CNT_OVF82	= r7 ;{		;; счетчик переполнений таймера 82 для задержки контроля кнопок
;; счетчик обратного отсчета, CNT_OVF82 = 0 - реагируем на кнопки.
;; каждое нажатие кнопки устанавливает CNT_OVF82 в число итераций таймера 82 (по 32мс),
;; по декрементации CNT_OVF82 до 0 вновь проверяем кнопки
;}	
.def STEP_CYKL		= r6 ;{		;; текущее состояние цикла настройки
;; описание шагов в тексте Analiz_UART_CYKL
;}	
;;=========================================================================================================
.cseg ;{	;; Таблица прерываний 
.org 0x0000		rjmp start
.org INT0addr	reti		;;		= 0x0001	; External Interrupt Request 0
.org INT1addr	reti		;;		= 0x0002	; External Interrupt Request 1
.org OC2addr	reti		;;		= 0x0003	; Timer/Counter2 Compare Match
.org OVF2addr	rjmp Interrupt_OverFlow_82		;;		= 0x0004	; Timer/Counter2 Overflow
.org ICP1addr	reti		;;		= 0x0005	; Timer/Counter1 Capture Event
.org OC1Aaddr	reti		;;		= 0x0006	; Timer/Counter1 Compare Match A
.org OC1Baddr	reti		;;		= 0x0007	; Timer/Counter1 Compare Match B
.org OVF1addr	rjmp Interrupt_OverFlow_161		;;		= 0x0008	; Timer/Counter1 Overflow
.org OVF0addr	rjmp Interrupt_OverFlow_80		;;		= 0x0009	;  Timer/Counter0 Overflow
.org SPIaddr	reti		;;		= 0x000a	; Serial Transfer Complete
.org URXCaddr	rjmp Interrupt_USART_RX_Complete		;;		= 0x000b	; USART, Rx Complete
.org UDREaddr	reti		;;		= 0x000c	; USART Data Register Empty
.org UTXCaddr	reti		;;		= 0x000d	; USART, Tx Complete
.org ADCCaddr	reti		;;		= 0x000e	; ADC Conversion Complete
.org ERDYaddr	reti		;;		= 0x000f	; EEPROM Ready
.org ACIaddr	reti		;;		= 0x0010	; Analog Comparator
.org TWIaddr	reti		;;		= 0x0011	; 2-wire Serial Interface
.org SPMRaddr	reti		;;		= 0x0012	; Store Program Memory Ready
;}	
;{		;; Фьюзы
;;=========================================================================================================
;; для F=8МГц (внутренний RC генератор)
;; Фьюзы: для USBASP 1 => установленный бит => галки нет
;;					0 => сброшенный бит => отмечено галкой
;; все биты LOCK установлены
;;---- Fuse High Byte ----
;; RSTDISBL - 1 недоступен
;; WDTON - 1
;; SPIEN - 0 недоступен
;; CKOPT - 1
;; EESAVE - 1
;; BOOTSZ1 - 0
;; BOOTSZ0 - 0
;; BOOTRST - 1
;;---- Fuse Low Byte ----
;; BODLEVEL - 1
;; BODEN - 1
;; SUT1 - 1
;; SUT0 - 0
;; CKSEL3 - 0
;; CKSEL2 - 1
;; CKSEL1 - 0
;; CKSEL0 - 0
;}
;;=========================================================================================================
.org 0x018	;; для ATMega8 INT_VECTORS_SIZE	= 19*words = 0x02A - размер поля для векторов прерывания
start: ;{
	ldi r16,low(RAMEND)
	out spl,r16
	ldi r16,high(RAMEND)
	out sph,r16
	clr r10					;; R10 - 00000000
	ser r16
	mov r11,r16				;; R11 - 11111111
	
	rcall d_200ms
;;=========================================================================================================
;; Настройка портов 
;; Порт B
;; PB3 Debug TXD из МК  - вывод настраиваем на выход с 1 в исходном состоянии
	ldi r16,0b00001000
	out DDRB,r16
	out PORTB,r16

;; Порт C
;; PC0 кнопка "Старт"
;; PC1 кнопка "Пауза"
;; PC3 кнопка "Стоп"
;; PC4 линия SDA внешней EEPROM 24LC512
;; PC5 линия SCL внешней EEPROM 24LC512
	out DDRC,r10			;; все выводы работают как вход
	ldi r16,0b00000111
	out PORTC,r16		;; резисторная подтяжка на кнопки

;;  Порт D
;; PD0 RXD в МК
;; PD1 TXD из МК
;; PD2 INT0 
;; PD3 INT1 DSR в МК
;; PD4 DTR из МК
;; PD5 debug TXD из МК
;; PD6 выход на контрольный светодиод RED
;; PD7 выход на контрольный светодиод GREEN
	ldi r16,0b11110000
	out DDRD,r16
	ldi r16,0b00110000
	out PORTD,r16

;;=========================================================================================================
;; Настройка UART на 38400 bps(бод)
	out UBRRH,r10	;; предделитель старший разряд
	ldi r16,12		;; UBRR = 8000000/(16 * 38400) - 1 = 12,02 //при U2X = 0
	out UBRRL,r16	;; предделитель младший разряд
	ldi r16,(1 << RXEN)|(1 << TXEN)|(1 << RXCIE)	;; вкл приемник(RXEN=1),вкл передатчик(TXEN=1),вкл прерывание по приему(RXCIE=1)
	out UCSRB,r16
	;; Для доступа к регистру UCSRC ОБЯЗАТЕЛЬНО выставить бит URSEL!!!
	ldi r16,(1 << URSEL)|(3 << UCSZ0)	;; асинхронный режим(UMSEL=0), 8 бит(UCSZ2-0=011), 1 стоп-бит(USBS=0),без контроля четности(UPM1-0=00)
	out UCSRC,r16
;;=========================================================================================================
;; Настройка TWI на SCL = 100kHg
	ldi r16,32		;; Fscl = 8000000/(16 + 2 * TWBR * 4^TWPS); 100000 = 8000000/(16 + 2 * 32 * 4^0)
	out TWBR,r16	;; предделитель младший разряд
;;=========================================================================================================
;; Настройка таймеров
	ldi r16,(1 << TOIE1)|(1 << TOIE0)|(1 << TOIE2)
	out TIMSK,r16			;; разрешить прерывание по переполнению 0(8разр TOIE0), 1(16разр TOIE1) и 2(8разр TOIE2) счетчиков
;;=========================================================================================================
;; инициализация буферов и переменных
	clr ANS_RS_SUM
	clr ANS_RS_CNT
	clr ANS_RS_COM
	clr ANS_RS_VAL
	clr CNT_OVF82
	clr STEP_CYKL
	clr ERROR				;; очистим регистр ошибок
	clr STATUS				;; очистим регистр состояния
;;=========================================================================================================
;; проверка линии DSR (ответ РС на активизацию RS232) до активизации RS232
	clt				;; сбросим флаг Т
	sbis PIND,3		;; DSR пропустить если бит в порту 1 (если вдруг порт РС не активен - нормально))
	set				;; установим флаг Т - порт РС не должен быть активен
	
	rcall d_5sec	;; время необходимое для загрузки РС
	rcall d_1sec	;; время необходимое для загрузки РС
	cbi PORTD,4		;; DTR (1=>0 переход в активное состояние) активизируем RS232
	rcall d_200ms	;; подождем
	;; проверим ответ РС
	sbic PIND,3		;; DSR пропустить если бит в порту 0 (1=>0 переход в активное состояние РС)
	set				;; установим флаг Т - нет ответа на активизацию порта РС
	brtc go0001		;; перейти если Т = 0 - все нормально и РС включила порт
;; -----------------------
;; Отладочная фишка - нажатое состояние кнопки "Старт" при включении - режим обмена с радиостанцией
	;; sbis PINC,0			;; пропустить если 1 (кн. "Старт" отпущена)
	;; rjmp go0001
;; -----------------------
	SetBit STATUS,7	;; (7 бит)режим обмена с компьютером
	
go0001:	
	sbrc STATUS,7	
	sbi PORTD,7 ;; GREEN	;; обмен с компьютером
	sbrs STATUS,7
	sbi PORTD,6 ;; RED	;; обмен с РС					

;; -----------------------
;; Ждем если кнопки оказались нажаты
strt01:
	sbis PINC,0			;; пропустить если 1 (кн. "Старт" отпущена)
	rjmp strt01
	sbis PINC,1			;; пропустить если 1 (кн. "Пауза" отпущена)
	rjmp strt01
	sbis PINC,2			;; пропустить если 1 (кн. "Стоп" отпущена)
	rjmp strt01
;; -----------------------
	rcall d_200ms
	cbi PORTD,6 ;; RED
	cbi PORTD,7 ;; GREEN
;;=========================================================================================================
	rcall CheckEEpromValues
	sei
;}
;;=========================================================================================================
loop: ;{
				tst ERROR
				breq lpNotERR ;{
				;; если произошна ошибка
				rcall SaveDebugINFO		;; сохраняем рабочие регистры во внутренней EEPROM
		lpE_repit:
				;; мигаем красным светодиодом
				sbi PORTD,6 ;RED	;; ERROR
				rcall d_200ms
				cbi PORTD,6 ;RED
				rcall d_200ms
				tst CNT_OVF82	;; проверка возможности контроля кнопок
				brne lpE_repit
				;; Проверяем кнопки
					sbic PINC,0			;; пропустить если 0 (кн. "Старт" нажата)
					rjmp lpE01
					rcall RunDelayButton ;{	;; запуск блокировки кнопок
					;; что-то делаем по нажатию кнопки "Старт"
						rcall SendDebugINFO_USART	;; отправляем рабочие регистры из внутренней EEPROM по USART
						rjmp lpE_repit
					;}
		lpE01:
					sbic PINC,1			;; пропустить если 0 (кн. "Пауза" нажата)
					rjmp lpE02
					rcall RunDelayButton ;{	;; запуск блокировки кнопок
					;; что-то делаем по нажатию кнопки "Пауза"
						rcall SendDebugINFO_PB3	;; отправляем рабочие регистры из внутренней EEPROM на PB3 (а ля RS232)
						rjmp lpE_repit
					;}
		lpE02:
					sbic PINC,2			;; пропустить если 0 (кн. "Стоп" нажата)
					rjmp lpE_repit
					rcall RunDelayButton ;{	;; запуск блокировки кнопок
					;; что-то делаем по нажатию кнопки "Стоп"
						clr ANS_RS_SUM
						clr ANS_RS_CNT
						clr ANS_RS_COM
						clr ANS_RS_VAL
						clr STEP_CYKL
						clr ERROR				;; очистим регистр ошибок
						;; очистим регистр состояния сохраняя режим работы
						mov r16,STATUS
						cbr r16,0b01111111
						mov STATUS,r16
						;; гасим светодиоды
						cbi PORTD,6 ;; RED
						cbi PORTD,7 ;; GREEN
						rjmp loop
					;}
				;}
	lpNotERR:	;;=================================
				sbrc STATUS,7			;; проверка режима работы
				rjmp lpPC
				;{ ;; Режим обмена с Р-168-5КН1 =================================================================
					sbrc STATUS,3		;; конец задержки 16бит. таймера в цикле сканирования
					rjmp lp08
					sbrs STATUS,6		;; пропустить если есть принятое сообщение по RS232
					rjmp lp_button
					sbrs STATUS,0		;; пропустить если запущено сканирование
					rjmp lp04
		lp08:
					rcall Analiz_UART_CYKL	;;текущая обработка ситуации в режиме сканирования
					rjmp lp_button
		lp04:
					rcall Analiz_UART_RS
		lp_button:
					tst CNT_OVF82	;; проверка возможности контроля кнопок
					brne loop
					
					;;если пауза мигнем зеленым
					sbrs STATUS,1	;; если уже пауза
					rjmp lp03
					sbrc STATUS,0	;; и если цикл уже остановлен
					rjmp lp03
					
					sbi PORTD,7 ;; GREEN
					rcall d_200ms
					cbi PORTD,7 ;; GREEN
					rcall d_200ms
					
		lp03:		;; Проверяем кнопки
					sbic PINC,0			;; пропустить если 0 (кн. "Старт" нажата)
					rjmp lp05
					rcall RunDelayButton	;; запуск блокировки кнопок
					;; что-то делаем по нажатию кнопки "Старт"
						sbrc STATUS,1		;; пропустить если пауза
						rjmp loop
						sbrc STATUS,0		;; пропустить если запущено сканирование
						rjmp loop
						rcall CYKL_START	;;запускаем сканирование
					rjmp loop
		lp05:
					sbic PINC,1			;; пропустить если 0 (кн. "Пауза" нажата)
					rjmp lp06
					rcall RunDelayButton	;; запуск блокировки кнопок
					;; что-то делаем по нажатию кнопки "Пауза"
						mov r16,STATUS
						andi r16,3		;; оставим первые два бита
						cpi r16,1		;;P=0,S=1 если идет сканирование
						brne lp052
						rcall CYKL_Pause_ON
			lp052:
						cpi r16,2		;;P=1,S=0
						brne lp053
						rcall CYKL_Pause_OFF
			lp053:		;; ситуация когда P=1,S=1 означает что пауза уже включена но цикл одной частоты не дошел до конца
					rjmp loop
		lp06:
					sbic PINC,2			;; пропустить если 0 (кн. "Стоп" нажата)
					rjmp loop
					rcall RunDelayButton	;; запуск блокировки кнопок
					;; что-то делаем по нажатию кнопки "Стоп"
						mov r16,STATUS
						andi r16,3		;; оставим первые два бита
						tst r16
						breq lp062
							rcall CYKL_STOP	;; идем если было сканирование или пауза
			lp062:	rjmp loop
				;}
	lpPC:		;{ ;; Режим обмена с ПК =================================================================
				sbrc STATUS,6		;; пропустить если нет принятого сообщение по RS232 в буфер buf_RX и оно не обработано
				rcall Analiz_UART_PC

					tst CNT_OVF82	;; проверка возможности контроля кнопок
					breq lpPC00
					rjmp loop
		lpPC00:		;; Проверяем кнопки
					sbic PINC,0			;; пропустить если 0 (кн. "Старт" нажата)
					rjmp lpPC01
					rcall RunDelayButton ;{	;; запуск блокировки кнопок
					;; что-то делаем по нажатию кнопки "Старт"
						rcall PushStartOnPC
					rjmp loop
					;}
		lpPC01:
					sbic PINC,1			;; пропустить если 0 (кн. "Пауза" нажата)
					rjmp lpPC02
					rcall RunDelayButton ;{	;; запуск блокировки кнопок
					;; что-то делаем по нажатию кнопки "Пауза"
						rcall PushPauseOnPC
					rjmp loop
					;}
		lpPC02:
					sbic PINC,2			;; пропустить если 0 (кн. "Стоп" нажата)
					rjmp loop
					rcall RunDelayButton ;{	;; запуск блокировки кнопок
					;; что-то делаем по нажатию кнопки "Стоп"
						rcall PushStopOnPC
					rjmp loop
					;}
				;}
				
rjmp loop ;}
;;=========================================================================================================
PushStartOnPC: ;{		;; Нажатие "Старт" в режиме обмена с ПК
				LdiX(buf_TX)
				ldi r16,5
				st x+,r16
				ldi r16,'I'
				st x+,r16
				ldi r16,'W'
				st x+,r16
				ldi r16,'T'
				st x+,r16
				ldi r16,'G'
				st x+,r16
				ldi r16,'D'
				st x+,r16
				rcall SetCheckSummTX
				rcall SendTX
ret ;}
PushPauseOnPC: ;{		;; 
				;; LdiX(i24Tmp1)
				;; st x+,r10
				;; st x+,r10
				;; st x+,r10
				;; sbiw xl,3
				;; LdiY(eeERR_CNT)
				;; rcall Write3_X_eeY
				
				
				;; ld r16,y+
				;; rcall Send_Byte_USART


ret ;}
PushStopOnPC: ;{		;; 
				;; LdiX(i24Tmp1)
				;; ldi r16,$0A
				;; st x+,r16
				;; st x+,r10
				;; st x+,r10
				;; sbiw xl,3
				;; LdiY(eeERR_CNT)
				;; rcall Write3_X_eeY

ret ;}

RunDelayButton: ;{		;; 
				push r16
				
				ldi r16,32		
				mov CNT_OVF82,r16
				;; первичный запуск счетчика (установка предделителей 80 и 82 РАЗНЫЕ!!!)
				out TCNT2,r10		;; обнулим счетчик таймера
				ldi r16,0b00000111	;; (такт = 0,125мкс) * 1024 * 256 = 32.768 мс
				;; ldi r16,0b00000110	;; (такт = 0,125мкс) * 256 * 256 = 8.192 мс
				;; ldi r16,0b00000101	;; (такт = 0,125мкс) * 128 * 256 = 4.096 мс
				;; ldi r16,0b00000100	;; (такт = 0,125мкс) * 64 * 256 = 2.048 мс
				;; ldi r16,0b00000011	;; (такт = 0,125мкс) * 32 * 256 = 1.024 мс
				;; ldi r16,0b00000010	;; (такт = 0,125мкс) * 8 * 256 = 256 мkс
				out TCCR2,r16		;; пуск счетчик
				
				pop r16
ret ;}

Analiz_UART_PC: ;{		;; анализ сообщений из компьютера
				sbi PORTD,7		;; GREEN
				movw r24,r12		;; r25 = ANS_RS_COM	;; r24 = ANS_RS_VAL
				;; анализируем на ответ
				cpi r25,$50			;; "PING" готовность устройства
				brne alzpc02		;; если не совпало
					rcall AnswerPING_PC
					rjmp alzpc_exit
	alzpc02: ;; ========================================================	
				cpi r25,$53	;{ 		;; "SET" блок инструкций SET
				breq alzpc021
				rjmp alzpc03		;; если не совпало
		alzpc021: ;; ========================================================
					cpi r24,$01		;; "FSTART" установка начальной частоты
					brne alzpc022
						LdiY(i24TmpRS)
						LdiZ(constFreqMin * 2)	;; проверка на минимум
						rcall Compare3_Zm_Y	;; На выходе флаги Z = 1 (Y == X); C = 1 (Y < X); если (Y > X) флаги Z и C = 0.
						breq alzpc0212		;; Z = 1 т.е. Z = Y
						brlo alzpc0212		;; C = 1 т.е. Z < Y
						rcall SendERROR_PC
					rjmp alzpc_exit
			alzpc0212:	
						LdiZ(constFreqMax * 2)	;; проверка на максимум
						LdiY(i24TmpRS)
						rcall Compare3_Zm_Y	;; На выходе флаги Z = 1 (Y == X); C = 1 (Y < X); если (Y > X) флаги Z и C = 0.
						brsh alzpc0213		;; C = 0 т.е. Z >= Y
						rcall SendERROR_PC
						rjmp alzpc_exit
			alzpc0213:	
						LdiX(i24TmpRS)
						LdiY(eeFstart)
						rcall Write3_X_eeY
						rcall SendOK_PC
						rjmp alzpc_exit
		alzpc022: ;; ========================================================
					cpi r24,$02		;; "FSTOP" установка конечной частоты
					brne alzpc023
						LdiY(i24TmpRS)
						LdiZ(constFreqMin * 2)	;; проверка на минимум
						rcall Compare3_Zm_Y	;; На выходе флаги Z = 1 (Y == X); C = 1 (Y < X); если (Y > X) флаги Z и C = 0.
						breq alzpc0222		;; Z = 1 т.е. Z = Y
						brlo alzpc0222		;; C = 1 т.е. Z < Y
						rcall SendERROR_PC
					rjmp alzpc_exit
			alzpc0222:	
						LdiZ(constFreqMax * 2)	;; проверка на максимум
						LdiY(i24TmpRS)
						rcall Compare3_Zm_Y	;; На выходе флаги Z = 1 (Y == X); C = 1 (Y < X); если (Y > X) флаги Z и C = 0.
						brsh alzpc0223		;; C = 0 т.е. Z >= Y
						rcall SendERROR_PC
						rjmp alzpc_exit
			alzpc0223:	
						LdiX(i24TmpRS)
						LdiY(eeFstop)
						rcall Write3_X_eeY
						rcall SendOK_PC
						rjmp alzpc_exit
		alzpc023: ;; ========================================================
					cpi r24,$03		;; "FSTEP" установка шага перестройки частоты
					breq alzpc0231
					rjmp alzpc_err
			alzpc0231:
						LdiY(i24TmpRS)
						LdiZ(constStepMin * 2)	;; проверка на минимум
						rcall Compare3_Zm_Y	;; На выходе флаги Z = 1 (Y == X); C = 1 (Y < X); если (Y > X) флаги Z и C = 0.
						breq alzpc0232		;; Z = 1 т.е. Z = Y
						brlo alzpc0232		;; C = 1 т.е. Z < Y
						rcall SendERROR_PC
					rjmp alzpc_exit
			alzpc0232:	
						LdiZ(constStepMax * 2)	;; проверка на максимум
						LdiY(i24TmpRS)
						rcall Compare3_Zm_Y	;; На выходе флаги Z = 1 (Y == X); C = 1 (Y < X); если (Y > X) флаги Z и C = 0.
						brsh alzpc0233		;; C = 0 т.е. Z >= Y
						rcall SendERROR_PC
						rjmp alzpc_exit
			alzpc0233:	
						LdiX(i24TmpRS)
						LdiY(eeFstep)
						rcall Write3_X_eeY
						rcall SendOK_PC
						rjmp alzpc_exit
				;}
	alzpc03: ;; ========================================================
				cpi r25,$47	;{ 		;; "GET" блок инструкций GET
				brne alzpc_err
					cpi r24,$01		;; "FSTART" запрос начальной частоты
					brne alzpc032
						mov r17,r24
						LdiY(eeFstart)
						rcall SendR17eeY_FREQ_PC	;; r17 - 01 eeFstart; 02 eeFstop; 03 eeFstep  !!!функция использует i24Tmp1!!!
					rjmp alzpc_exit
		alzpc032: ;; ========================================================
					cpi r24,$02		;; "FSTOP" запрос конечной частоты
					brne alzpc033
						mov r17,r24
						LdiY(eeFstop)
						rcall SendR17eeY_FREQ_PC	;; r17 - 01 eeFstart; 02 eeFstop; 03 eeFstep  !!!функция использует i24Tmp1!!!
					rjmp alzpc_exit
		alzpc033: ;; ========================================================
					cpi r24,$03		;; "FSTEP" запрос шага перестройки
					brne alzpc034
						mov r17,r24
						LdiY(eeFstep)
						rcall SendR17eeY_FREQ_PC	;; r17 - 01 eeFstart; 02 eeFstop; 03 eeFstep !!!функция использует i24Tmp1!!!
					rjmp alzpc_exit
		alzpc034: ;; ========================================================
					cpi r24,$0E		;; "ERRORS" запрос ошибок последнего цикла настройки
					brne alzpc035
						rcall SendPackERRORS_PC
					rjmp alzpc_exit
		alzpc035: ;; ========================================================
					cpi r24,$EE		;; "ERRORS" запрос выдать ошибки работы сканера
					brne alzpc_err
						rcall SendDebugINFO_PC
					rjmp alzpc_exit
				;}
	alzpc_err:
				SetBit ERROR,4	;; ошибка - неопознанная инструкция
	alzpc_exit:
				clr ANS_RS_COM
				clr ANS_RS_VAL
				clr ANS_RS_CNT
				clr ANS_RS_SUM
				ClrBit STATUS,6			;; сброс принятого сообщения по RS232 в буфер buf_RX
				cbi PORTD,7		;; GREEN
ret ;}
Analiz_UART_RS: ;{		;; анализ сообщений из радиостанции НЕ в режиме сканирования
				
				
				;; movw r24,r12		;; r25 = ANS_RS_COM	;; r24 = ANS_RS_VAL
;; ;; r25 = ANS_RS_COM	;; r24 = ANS_RS_VAL
;; mov r16,ANS_RS_COM
;; rcall Send_Byte_USART
;; mov r16,ANS_RS_VAL
;; rcall Send_Byte_USART
;; mov r16,ANS_RS_COM
;; cpi r16,$50
;; brne ffffff
;; SetBit STATUS,5
;; ffffff:

				clr ANS_RS_COM
				clr ANS_RS_VAL
				clr ANS_RS_CNT
				clr ANS_RS_SUM
				ClrBit STATUS,6			;; сброс принятого сообщения по RS232 в буфер buf_RX
ret ;}
Analiz_UART_CYKL: ;{	;; анализ сообщений из радиостанции в режиме сканирования
;; эта функция проходит из loop когда есть принятое сообщение или наступил конец задержки 16бит. таймера в цикле сканирования				
				out TCCR1B,r10			;; Останавливаем 16 битный счетчик.
				movw r24,r12		;; r24 = ANS_RS_VAL(r13)	r25 = ANS_RS_COM(r12)
				mov r23,STEP_CYKL
				
				;; проверим на ошибку в командах
				cpi r25,$03
				brne cycl_001
				mov r16,r24
				andi r16,$0F			;; оставим младшую тетраду
				cpi r16,$06
				brne cycl_001
				SetBit ERROR,1			;; ошибка - получен ответ $66
				SetBit ERROR,0
				rjmp cycl_exit
	cycl_001:
				cpi r23,1
				brne cycl_002
				;{ ;; STEP_CYKL = 1
					;; есть какое-то сообщение, ждем только ANS_RS_COM = $03 & ANS_RS_VAL = $07
					cpi r25,$03
					breq cycl_0011
					rjmp cycl_exit
		cycl_0011:
					cpi r24,$07
					breq cycl_0012
					rjmp cycl_exit
		cycl_0012:	;; команда нажатия кнопки 1 выполнена
					inc STEP_CYKL	;;=2
					;; rcall d_200ms
					rcall SendRS_ChangeFREQ		;; посылаем команду смены частоты
					rjmp cycl_exit
				;}
	cycl_002:
				cpi r23,2
				brne cycl_003
				;{ ;; STEP_CYKL = 2
					;; есть какое-то сообщение, ждем только ANS_RS_COM = $03 & ANS_RS_VAL = $47
					cpi r25,$03
					breq cycl_0021
					rjmp cycl_exit
		cycl_0021:
					cpi r24,$47
					breq cycl_0022
					rjmp cycl_exit
		cycl_0022:	;; команда смены частоты
					inc STEP_CYKL	;;=3
					;; rcall d_200ms
					rcall SendRS_PUSH1 		;;отправим команду нажатия первой кнопки (для вывода частоты на табло радиостанции)
					rjmp cycl_exit
				;}
	cycl_003:
				cpi r23,3
				brne cycl_004
				;{ ;; STEP_CYKL = 3
					;; есть какое-то сообщение, ждем только ANS_RS_COM = $03 & ANS_RS_VAL = $07
					cpi r25,$03
					breq cycl_0031
					rjmp cycl_exit
		cycl_0031:
					cpi r24,$07
					breq cycl_0032
					rjmp cycl_exit
		cycl_0032:	;; команда нажатия кнопки 1 выполнена
					inc STEP_CYKL	;;=4
					;; запускаем 16 битный таймер
					ClrBit STATUS,4			;; задержка в цикле сканирования
					out TCNT1H,r10
					out TCNT1L,r10
					;; ldi r16,0b00000000		;; счетчик остановлен
					;; ldi r16,0b00000001		;; 0,125мкс*1*65536 = 8.192мс (переполнение счетчика)
					;; ldi r16,0b00000010		;; 0,125мкс*8*65536 = 65.536мс (переполнение счетчика)
					;; ldi r16,0b00000011		;; 0,125мкс*64*65536 = 524.288мс (переполнение счетчика)
					ldi r16,0b00000100		;; 0,125мкс*256*65536 = 2.097с (переполнение счетчика)
					;; ldi r16,0b00000101		;; 0,125мкс*1024*65536 = 8.388с (переполнение счетчика)
					out TCCR1B,r16
					rjmp cycl_exit
				;}
	cycl_004:
				cpi r23,4
				brne cycl_005
				;{ ;; STEP_CYKL = 4
					sbrs STATUS,3			;; конец задержки 16бит. таймера в цикле сканирования
					rjmp cycl_exit
					ClrBit STATUS,3
					inc STEP_CYKL	;;=5
					SetBit STATUS,5			;; включаем ожидание текстовой посылки 256 байт о настройке
					rcall SendRS_TuneASU		;; посылаем команду настройки АСУ
				;}
	cycl_005:
				cpi r23,5
				brne cycl_006
				;{ ;; STEP_CYKL = 5
					;; есть какое-то сообщение, ждем только ANS_RS_COM = $03 & ANS_RS_VAL = $37
					cpi r25,$03
					breq cycl_0051
					rjmp cycl_exit
		cycl_0051:
					cpi r24,$37
					breq cycl_0052
					rjmp cycl_exit
		cycl_0052:	;; команда настройки АСУ выполнена
					inc STEP_CYKL	;;=6
					rjmp cycl_exit
				;}
	cycl_006:
				cpi r23,6
				brne cycl_007
				;{ ;; STEP_CYKL = 6
					;; ;; есть какое-то сообщение, ждем только ANS_RS_COM = $FF & ANS_RS_VAL = $??
					cpi r25,$FF
					breq cycl_0061
					rjmp cycl_exit
		cycl_0061:
					ClrBit STATUS,5			;; выключаем ожидание текстовой посылки 256 байт о настройке
					cpi r24,$15
					breq cycl_0062
					;; АСУ не настроено
						LdiY(eeERR_CNT)		;; eeERR_CNT возможно до 21758(вкл)
						LdiX(i24Tmp1)
						rcall Read3_eeY_X	;; загрузим счетчик ошибок в i24Tmp1
						LdiZ(err_cnt_max * 2)	;; проверка на максимум (<=21758)
						LdiY(i24Tmp1)
						rcall Compare3_Zm_Y	;; флаги Z = 1 числа равны; N = 1 (Z < Y); если (Z > Y) флаги Z и N = 0.
						breq cycl_0063		;; Z = 1 т.е. Z = Y
						brpl cycl_0063		;; N = 0 т.е. Z > Y
						SetBit ERROR,3		;; ошибка - переполнение EEPROM
						rjmp cycl_exit
			cycl_0063:	
						;; множим i24Tmp1 на 3
						LdiX(i24Tmp1)
						rcall MULinXto3			;; умножить значение по адресу X на 3. указатель X восстанавливается
						;; добавим i24Tmp1 к указателю поля ошибок
						LdiY(eeFREQS_ERR)
						rcall ADD_YinX16			;; сложить указатель Y и значение по адресу X; результат в Y
						;; сохраним сбойную частоту
						LdiX(CurFreq)
						rcall Write3_X_eeY
						;; вновь берем значение eeERR_CNT, инкременируем и сохраняем обратно в EEPROM
						LdiY(eeERR_CNT)
						LdiX(i24Tmp1)
						rcall Read3_eeY_X	;; загрузим счетчик ошибок в i24Tmp1
						rcall INCinX24
						rcall Write3_X_eeY
		cycl_0062:
					;; АСУ настроено
					rcall CYKL_Continue
					rjmp cycl_exit
				;}
	cycl_007:
				cpi r23,10
				brne cycl_exit
				;{ ;; STEP_CYKL = 10
					sbrs STATUS,3			;; конец задержки 16бит. таймера в цикле сканирования
					rjmp cycl_exit
					ClrBit STATUS,3
					ldi r16,2
					mov STEP_CYKL,r16
					rcall SendRS_ChangeFREQ		;; посылаем команду смены частоты
				;}

	cycl_exit:
				clr ANS_RS_COM
				clr ANS_RS_VAL
				clr ANS_RS_CNT
				clr ANS_RS_SUM
				ClrBit STATUS,6			;; сброс принятого сообщения по RS232 в буфер buf_RX
;; ldi r16,$CC
;; rcall Send_Byte_USART
;; mov r16,STEP_CYKL
;; rcall Send_Byte_USART
ret ;}
CYKL_Continue: ;{
				;; прибавим к текущей частоте шаг перестройки
				LdiY(eeFstep)
				LdiX(i24Tmp1)
				rcall Read3_eeY_X	;; загрузим шаг перестройки в i24Tmp1
				LdiY(CurFreq)
				LdiX(i24Tmp2)
				rcall Copy3_Y_X
				LdiY(i24Tmp2)		;;здесь сейчас CurFreq
				LdiX(i24Tmp1)		;;здесь сейчас eeFstep
				rcall ADD_Y24_X24		;; сложим, i24Tmp2 = CurFreq + eeFstep
				;; сравним CurFreq с eeFstop
				LdiY(eeFstop)
				LdiX(i24Tmp1)
				rcall Read3_eeY_X	;; загрузим конечную частоту в i24Tmp1
				LdiY(i24Tmp1)		;; Y = eeFstop - конечная частота
				LdiX(i24Tmp2)		;; X = CurFreq + eeFstep
				rcall Compare3_Y_X	;; На выходе флаги Z = 1 (Y == X); C = 1 (Y < X); если (Y > X) флаги Z и C = 0.
				brsh cyklcnt01		;;C = 0 т.е. Y >= X
				;; текущая частота стала больше конечной
				rcall CYKL_STOP
				ret
	cyklcnt01:	
				sbrs STATUS,1		;; пропустить если пауза
				rjmp cyklcnt02
				;; включен режим пауза но сканирование шло
				rcall CYKL_STOP
				SetBit STATUS,1		;; восстановим режим "пауза"
				ret
	cyklcnt02:	
				;; продолжаем цикл
				;; заносим i24Tmp2(CurFreq + eeFstep) в CurFreq
				LdiY(i24Tmp2)		;;здесь сейчас CurFreq + eeFstep
				LdiX(CurFreq)
				rcall Copy3_Y_X
				
				ldi r16,10
				mov STEP_CYKL,r16
				;; запускаем 16 битный таймер
				ClrBit STATUS,4			;; задержка в цикле сканирования
				out TCNT1H,r10
				out TCNT1L,r10
				;; ldi r16,0b00000000		;; счетчик остановлен
				;; ldi r16,0b00000001		;; 0,125мкс*1*65536 = 8.192мс (переполнение счетчика)
				;; ldi r16,0b00000010		;; 0,125мкс*8*65536 = 65.536мс (переполнение счетчика)
				ldi r16,0b00000011		;; 0,125мкс*64*65536 = 524.288мс (переполнение счетчика)
				;; ldi r16,0b00000100		;; 0,125мкс*256*65536 = 2.097с (переполнение счетчика)
				;; ldi r16,0b00000101		;; 0,125мкс*1024*65536 = 8.388с (переполнение счетчика)
				out TCCR1B,r16
ret ;}
CYKL_START: ;{
				sbi PORTD,7 ;; GREEN
				sbi PORTD,6 ;; RED
				rcall d_200ms
				cbi PORTD,6 ;; RED
				
				;; обнулим счетчик ошибок
				LdiX(i24Tmp1)
				st x+,r10
				st x+,r10
				st x+,r10
				LdiX(i24Tmp1)	;;используем эту переменную как переменную с нулем
				LdiY(eeERR_CNT)
				rcall Write3_X_eeY	;; обнулим счетчик ошибок
				LdiY(eeFREQ_END)
				rcall Write3_X_eeY	;; обнулим частоту на которой остановились
				;; загрузим начальную частоту как текущую
				LdiX(CurFreq)
				LdiY(eeFstart)
				rcall Read3_eeY_X
				
				SetBit STATUS,0	;; установим режим "запущено сканирование"
				clr STEP_CYKL
				inc STEP_CYKL		;; = 1
				;; отправим команду нажатия первой кнопки
				rcall SendRS_PUSH1
ret ;}
CYKL_Pause_ON: ;{	;; остановка сканирования
				sbi PORTD,7 ;; GREEN
				sbi PORTD,6 ;; RED
				SetBit STATUS,1		;; установим флаг паузы
ret ;}
CYKL_Pause_OFF: ;{	;; продолжение сканирования
				SetBit STATUS,0	;; установим режим "запущено сканирование"
				ClrBit STATUS,1	;; снять режим "пауза"
				;; загрузим конечную частоту как текущую
				LdiX(CurFreq)
				LdiY(eeFREQ_END)
				rcall Read3_eeY_X
				
				clr STEP_CYKL
				inc STEP_CYKL		;; = 1
				;; отправим команду нажатия первой кнопки
				rcall SendRS_PUSH1
				
				cbi PORTD,6 ;; RED
				sbi PORTD,7 ;; GREEN
ret ;}
CYKL_STOP: ;{
				ClrBit STATUS,0	;; снять режим "запущено сканирование"
				ClrBit STATUS,1	;; снять режим "пауза"
				;; сохраним конечную частоту
				LdiY(eeFREQ_END)
				LdiX(CurFreq)
				rcall Write3_X_eeY
				
				sbi PORTD,7 ;; GREEN
				sbi PORTD,6 ;; RED
				rcall d_200ms
				cbi PORTD,7 ;; GREEN
				cbi PORTD,6 ;; RED
ret ;}
Interrupt_USART_RX_Complete: ;{	;; обработка прерывания при поступлении очередного байта в приемник UART
				cli
				push r25
				push r24
				push r23
				push r22
				push r21
				push r17
				push r16
				pushX
				in r16,SREG
				push r16
				
				out TCCR0,r10	;; стоп счетчик
				in r21,UDR
				sbrs STATUS,6		;; принято сообщение по RS232
				rjmp intusart01
				SetBit ERROR,5		;; прием байта по RS232 при необработанном прошлом сообщении
				rjmp intusartE
	intusart01:
				movw r22,r8			;; r22 = ANS_RS_SUM(r8)		r23 = ANS_RS_CNT(r9)
				movw r24,r12		;; r24 = ANS_RS_VAL(r13)	r25 = ANS_RS_COM(r12)
				clt					;; по умолчанию все сообщения сканеру нужны
				cpi r23,0 		;; если пришел 1_ый байт
				brne intusart02
					clr ANS_RS_SUM
					clr ANS_RS_CNT
					clr ANS_RS_VAL
					mov ANS_RS_COM,r21
				rjmp intusartEN
				;; начиная со второго байта анализируем исходя из типа сообщения
	intusart02:	;{	;; "P" - пинг ==================================================================
				cpi r25,$50			;; (hex: 50 50) "P" - пинг
				brne intusart03
					cpi r23,1		;; если пришел 2_ой байт
					breq intusart021
					rjmp intusartERROR
		intusart021:		
					rjmp intusartFinalByte
				;}
	intusart03:	;{	;; блок инструкций GET ==================================================================
				cpi r25,$47			;; "GET" блок инструкций GET
				brne intusart04
					cpi r23,1		;; если пришел 2_ой байт
					brne intusart031
					mov ANS_RS_VAL,r21
					rjmp intusartEN
		intusart031:		
					cpi r23,2		;; если пришел 3_ий байт
					breq intusart032
					rjmp intusartERROR
		intusart032:		
					rjmp intusartFinalByte
				;}
	intusart04:	;{	;; блок инструкций SET ==================================================================
				cpi r25,$53			;; "SET" блок инструкций SET
				brne intusart05
					cpi r23,1		;; если пришел 2_ой байт
					brne intusart041
					mov ANS_RS_VAL,r21
					rjmp intusartEN
		intusart041:		
					cpi r23,2		;; если пришел 3_ий байт
					brne intusart042
					LdiX(i24TmpRS)
					st x,r21
					rjmp intusartEN
		intusart042:		
					cpi r23,3		;; если пришел 4_ый байт
					brne intusart043
					LdiX(i24TmpRS + 1)
					st x,r21
					rjmp intusartEN
		intusart043:		
					cpi r23,4		;; если пришел 5_ый байт
					brne intusart044
					LdiX(i24TmpRS + 2)
					st x,r21
					rjmp intusartEN
		intusart044:		
					cpi r23,5		;; если пришел 6_ой байт
					breq intusart045
					rjmp intusartERROR
		intusart045:		
					rjmp intusartFinalByte
				;}
	intusart05:	;{	;; блок ответов радиостанции на команды из сканера ==================================================================
				cpi r25,$03			;; блок ответов радиостанции на команды из сканера
				brne intusart06
					cpi r23,1		;; если пришел 2_ой байт
					brne intusart051
					mov r16,r21
					lsl r16
					lsl r16
					lsl r16
					lsl r16
					mov ANS_RS_VAL,r16
					rjmp intusartEN
		intusart051:		
					cpi r23,2		;; если пришел 3_ий байт
					brne intusart052
					mov r16,r21
					andi r16,$0F		;;оставим младшую тетраду
					or ANS_RS_VAL,r16
					rjmp intusartEN
		intusart052:		
					cpi r23,3		;; если пришел 4_ый байт
					breq intusart053
					rjmp intusartERROR
		intusart053:		
					mov r16,ANS_RS_VAL
					andi r16,$0F		;;оставим младшую тетраду
					cpi r16,$08
					brne intusart054
					set
		intusart054:		
					rjmp intusartFinalByte
				;}
	intusart06:	;{	;; сообщение радиостанции о состоянии тангенты ==================================================================
				cpi r25,$07			;; сообщение радиостанции о состоянии тангенты
				brne intusart07
					cpi r23,2		;; если пришел 3_ий байт (состояние тангенты)
					brne intusart061
					mov ANS_RS_VAL,r21
		intusart061:
					cpi r23,7		;; если пришел 8_ой байт (последний)
					brpl intusart062	;; если r23 >= 8 
					rjmp intusartEN
		intusart062:
					brne intusart063	;; если r23 > 8 
					set		;; флаг прихода сообщения не устанавливать
					rjmp intusartFinalByte
		intusart063:
					rjmp intusartERROR
				;}
	intusart07:	;{	;; сообщение радиостанции о данных радиоканала ==================================================================
				cpi r25,$5A			;; сообщение радиостанции о данных радиоканала
				brne intusart08
					cpi r23,90		;; если пришел 91_ый байт (последний)
					brpl intusart071	;; если r23 >= 91 
					rjmp intusartEN
		intusart071:
					brne intusart072	;; если r23 > 91 
					set		;; флаг прихода сообщения не устанавливать
					rjmp intusartFinalByte
		intusart072:
					rjmp intusartERROR
				;}
	intusart08:	;{	;; текстовое сообщение радиостанции 256 байт ==================================================================
				cpi r25,$FF			;; текстовое сообщение радиостанции 256 байт
				brne intusart09
					cpi r23,2		;; если пришел 3_ий байт
					brne intusart081
					mov ANS_RS_VAL,r21
		intusart081:
					cpi r23,255		;; если пришел (0_ой)256_ой байт (последний)
					breq intusart082	;; если r23 >= 255 
					rjmp intusartEN
		intusart082:
					sbrs STATUS,5		;;ждем приема сообщения 256 байт о настройке АСУ
					set		;; флаг прихода сообщения не устанавливать
					mov r16,ANS_RS_VAL
					cpi r16,$15
					breq intusart083
					cpi r16,$16
					breq intusart083
					set		;; флаг прихода сообщения не устанавливать
		intusart083:
					rjmp intusartFinalByte
				;}
	intusart09:	;;==================================================================
				rjmp intusartERROR
;; mov r16,ANS_RS_COM
;; rcall Send_Byte_USART
;; mov r16,ANS_RS_VAL
;; rcall Send_Byte_USART
	intusartFinalByte:
				cp ANS_RS_SUM,r21
				breq intusartFin1
				SetBit ERROR,7		;; ошибка контрольной суммы в сообщении
				rjmp intusartERROR
		intusartFin1:
				brts intusartFin1n	;; если флаг Т установлен - сообщение сканеру ненужно
				SetBit STATUS,6		;; принято сообщение по RS232 в регистрах ANS_RS_COM и ANS_RS_VAL
				;; ClrBit STATUS,5		;; автосброс флага: ждем приема сообщения 256 байт о настройке АСУ
		intusartFin1n:
				clr ANS_RS_CNT
				rjmp intusartE
	
	intusartERROR:
				clr ANS_RS_SUM
				clr ANS_RS_CNT
				clr ANS_RS_COM
				clr ANS_RS_VAL
				SetBit ERROR,6		;; ошибка распознавания сообщения принятого по RS232
				rjmp intusartE
	intusartEN:
				inc ANS_RS_CNT
				add ANS_RS_SUM,r21
				;; запуск счетчика (установка предделителей 80 и 82 РАЗНЫЕ!!!)
				out TCNT0,r10		;; обнулим счетчик таймера
				ldi r16,0b00000100	;; (такт = 0,125мкс) * 256 * 256 = 8.192 мс
				;; ldi r16,0b00000011	;; (такт = 0,125мкс) * 64 * 256 = 2.048 мс
				;; ldi r16,0b00000010	;; (такт = 0,125мкс) * 8 * 256 = 256 мkс
				out TCCR0,r16		;; пуск счетчик
	intusartE:		
				pop r16
				out SREG,r16
				popX
				pop r16
				pop r17
				pop r21
				pop r22
				pop r23
				pop r24
				pop r25
				sei
reti ;}
Interrupt_OverFlow_80: ;{	;; время для приема очередного байта вышло - в буфере принята посылка
				cli
				push r16
				in r16,SREG
				push r16

				out TCCR0,r10			;; стоп счетчик
				tst ANS_RS_COM
				breq intovf80e
				SetBit ERROR,3			;; ошибка - необработанные данные принятые по RS232
	intovf80e:
				clr ANS_RS_COM
				clr ANS_RS_VAL
				clr ANS_RS_CNT
				clr ANS_RS_SUM
				
				pop r16
				out SREG,r16
				pop r16
				sei
reti ;}
Interrupt_OverFlow_82: ;{
				cli
				push r16
				in r16,SREG
				push r16

				out TCCR2,r10			;; стоп счетчик
				dec CNT_OVF82
				breq intovf82e
				;; последующий запуск счетчика (установка предделителей 80 и 82 РАЗНЫЕ!!!)
				out TCNT2,r10		;; обнулим счетчик таймера
				ldi r16,0b00000111	;; (такт = 0,125мкс) * 1024 * 256 = 32.768 мс
				;; ldi r16,0b00000110	;; (такт = 0,125мкс) * 256 * 256 = 8.192 мс
				;; ldi r16,0b00000101	;; (такт = 0,125мкс) * 128 * 256 = 4.096 мс
				;; ldi r16,0b00000100	;; (такт = 0,125мкс) * 64 * 256 = 2.048 мс
				;; ldi r16,0b00000011	;; (такт = 0,125мкс) * 32 * 256 = 1.024 мс
				;; ldi r16,0b00000010	;; (такт = 0,125мкс) * 8 * 256 = 256 мkс
				out TCCR2,r16		;; пуск счетчик
				
	intovf82e:
				pop r16
				out SREG,r16
				pop r16
				sei
reti ;}
Interrupt_OverFlow_161: ;{	;; время для ответа радиостанции вышло
				cli
				push r16
				in r16,SREG
				push r16

				out TCCR1B,r10			;; Останавливаем 16 битный счетчик.
				sbrs STATUS,4
				rjmp intovfl161
				SetBit ERROR,0	;; время для ответа радиостанции вышло
				rjmp intovfl16exit
	intovfl161:
				SetBit STATUS,3	;; конец задержки 16бит. таймера в цикле сканирования
	intovfl16exit:
				pop r16
				out SREG,r16
				pop r16
				sei
reti ;}
;;=========================================================================================================
.include "main_cont1.avr"
.include "twi.avr"
.include "delay.avr"
;;=========================================================================================================

	
	;; ld r16,x+
	;; rcall Send_Byte_USART
;; ldi r16,'T'
;; rcall Debug_Send_Byte

;; cbi PORTD,6 ;RED 2такта
;; cbi PORTD,7 ;GREEN 2такта





























